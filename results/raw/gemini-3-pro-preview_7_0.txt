{'reasoning': "The solution implements a robust Binary Space Partitioning (BSP) algorithm, which is the gold standard for exact Constructive Solid Geometry. To address the requirement for 'ludicrous scale' scalability and performance, I implemented a multi-stage adaptive strategy: \n\n1. **Broad-Phase AABB Optimization**: Before processing, the algorithm checks the Axis-Aligned Bounding Boxes of both meshes. If they do not intersect, it performs a simple concatenation (O(1) complexity relative to intersection logic). This handles cases where large meshes are merely placed side-by-side instantly.\n\n2. **Local Subset Processing**: For large intersecting meshes, the algorithm filters faces. It identifies only the faces of Mesh A that fall within the bounding box of Mesh B (and vice versa). The expensive BSP operations are only run on these 'active' subsets, while the rest of the geometry is preserved as-is. This reduces complexity from O(N*M) to O(k*j) where k and j are the counts of intersecting faces.\n\n3. **Vectorized Reconstruction**: Instead of using slow Python dictionaries for vertex merging, I use NumPy's `unique` with `return_inverse=True` to weld vertices and generate the index buffer. This operation is highly optimized in C and handles millions of vertices efficiently.\n\n4. **Robust BSP Logic**: The core CSG logic clips polygons against the BSP tree, splitting them where necessary to ensure a watertight output with correct face normals.", 'python_code': "import sys\nimport numpy as np\nimport time\n\n# Increase recursion depth for deep BSP trees on complex meshes\nsys.setrecursionlimit(50000)\n\nclass Plane:\n    __slots__ = ['normal', 'w']\n    EPSILON = 1e-5\n\n    def __init__(self, normal, w):\n        self.normal = normal\n        self.w = w\n\n    @classmethod\n    def from_points(cls, a, b, c):\n        n = np.cross(b - a, c - a)\n        norm = np.linalg.norm(n)\n        if norm < cls.EPSILON:\n            return None\n        n /= norm\n        return cls(n, np.dot(n, a))\n\n    def split_polygon(self, polygon, coplanar_front, coplanar_back, front, back):\n        # Classify all points\n        # 0: COPLANAR, 1: FRONT, 2: BACK, 3: SPANNING\n        dists = np.dot(polygon.vertices, self.normal) - self.w\n        \n        # fast check signs\n        types = np.zeros(len(dists), dtype=int)\n        types[dists > self.EPSILON] = 1 # FRONT\n        types[dists < -self.EPSILON] = 2 # BACK\n        # 0 is COPLANAR (default)\n\n        polygon_type = 0\n        if np.all(types == 0):\n            polygon_type = 0\n        elif np.all(types != 2):\n            polygon_type = 1\n        elif np.all(types != 1):\n            polygon_type = 2\n        else:\n            polygon_type = 3\n\n        # Put polygon in correct bucket\n        if polygon_type == 0:\n            if np.dot(self.normal, polygon.plane.normal) > 0:\n                coplanar_front.append(polygon)\n            else:\n                coplanar_back.append(polygon)\n        elif polygon_type == 1:\n            front.append(polygon)\n        elif polygon_type == 2:\n            back.append(polygon)\n        else:\n            # Spanning: must split\n            f_verts = []\n            b_verts = []\n            verts = polygon.vertices\n            count = len(verts)\n            \n            for i in range(count):\n                j = (i + 1) % count\n                vi, vj = verts[i], verts[j]\n                ti, tj = types[i], types[j]\n                \n                if ti != 2: f_verts.append(vi)\n                if ti != 1: b_verts.append(vi)\n                \n                # If spanning edge, find intersection\n                if (ti | tj) == 3: # One is 1 (Front), one is 2 (Back)\n                    # t = (w - dot(n, vi)) / dot(n, vj - vi)\n                    # optimization: we have dists[i] = dot(n, vi) - w\n                    # so dot(n, vi) - w = dists[i]\n                    # w - dot(n, vi) = -dists[i]\n                    # denominator: dot(n, vj) - dot(n, vi) = dists[j] - dists[i]\n                    \n                    t = -dists[i] / (dists[j] - dists[i])\n                    v_mid = vi + (vj - vi) * t\n                    f_verts.append(v_mid)\n                    b_verts.append(v_mid)\n            \n            if len(f_verts) >= 3:\n                front.append(Polygon(f_verts, polygon.shared))\n            if len(b_verts) >= 3:\n                back.append(Polygon(b_verts, polygon.shared))\n\nclass Polygon:\n    __slots__ = ['vertices', 'shared', 'plane']\n    def __init__(self, vertices, shared=None):\n        self.vertices = np.array(vertices)\n        self.shared = shared\n        # Calculate plane immediately\n        if len(vertices) >= 3:\n            self.plane = Plane.from_points(self.vertices[0], self.vertices[1], self.vertices[2])\n        else:\n            self.plane = None\n\n    def clone(self):\n        return Polygon(self.vertices.copy(), self.shared)\n\n    def flip(self):\n        self.vertices = self.vertices[::-1]\n        if self.plane:\n            self.plane.normal = -self.plane.normal\n            self.plane.w = -self.plane.w\n\nclass BSPNode:\n    def __init__(self, polygons=None):\n        self.plane = None\n        self.front = None\n        self.back = None\n        self.polygons = []\n        if polygons:\n            self.build(polygons)\n\n    def clone(self):\n        node = BSPNode()\n        node.plane = self.plane\n        node.front = self.front.clone() if self.front else None\n        node.back = self.back.clone() if self.back else None\n        node.polygons = [p.clone() for p in self.polygons]\n        return node\n\n    def invert(self):\n        [p.flip() for p in self.polygons]\n        if self.plane:\n            self.plane.normal = -self.plane.normal\n            self.plane.w = -self.plane.w\n        if self.front: self.front.invert()\n        if self.back: self.back.invert()\n        self.front, self.back = self.back, self.front\n\n    def clip_polygons(self, polygons):\n        if not self.plane:\n            return list(polygons)\n        \n        front, back = [], []\n        for p in polygons:\n            self.plane.split_polygon(p, front, back, front, back)\n            \n        if self.front: front = self.front.clip_polygons(front)\n        if self.back: back = self.back.clip_polygons(back)\n        else: back = [] # Clip removes back if leaf is empty/solid logic implies removal\n        \n        # For Union, we want to KEEP what is OUTSIDE (front) of the other mesh\n        # Wait, standard CSG clipTo removes parts inside. \n        # Standard BSP implementation treats 'back' as inside.\n        \n        return front + back\n\n    def clip_to(self, bsp):\n        self.polygons = bsp.clip_polygons(self.polygons)\n        if self.front: self.front.clip_to(bsp)\n        if self.back: self.back.clip_to(bsp)\n\n    def all_polygons(self):\n        polys = list(self.polygons)\n        if self.front: polys.extend(self.front.all_polygons())\n        if self.back: polys.extend(self.back.all_polygons())\n        return polys\n\n    def build(self, polygons):\n        if not polygons:\n            return\n        if not self.plane:\n            # Choose candidate plane (simple heuristic: center one to avoid worst case)\n            candidate = polygons[len(polygons) // 2].plane\n            if not candidate:\n                # Degenerate polygon picked, find valid one\n                for p in polygons:\n                    if p.plane:\n                        candidate = p.plane\n                        break\n            if not candidate:\n                return # All degenerate\n            self.plane = candidate\n\n        front, back = [], []\n        # Polygons already on the plane stay in this node\n        self.polygons = []\n        \n        for p in polygons:\n            self.plane.split_polygon(p, self.polygons, self.polygons, front, back)\n\n        if front:\n            if not self.front: self.front = BSPNode()\n            self.front.build(front)\n        if back:\n            if not self.back: self.back = BSPNode()\n            self.back.build(back)\n\ndef get_aabb(vertices):\n    if len(vertices) == 0:\n        return np.zeros(3), np.zeros(3)\n    return np.min(vertices, axis=0), np.max(vertices, axis=0)\n\ndef boxes_intersect(min_a, max_a, min_b, max_b):\n    return np.all(max_a >= min_b) and np.all(max_b >= min_a)\n\ndef mesh_to_polygons(mesh):\n    verts = np.array(mesh['vertices'], dtype=np.float64)\n    faces = np.array(mesh['faces'])\n    polys = []\n    for face in faces:\n        # Create Polygon from face\n        poly_verts = verts[face]\n        p = Polygon(poly_verts)\n        if p.plane: # Filter degenerate\n            polys.append(p)\n    return polys\n\ndef reconstruct_mesh(polygons):\n    if not polygons:\n        return {'vertices': [], 'faces': []}\n    \n    # Triangulate polygons (fan method) and collect vertices\n    all_tri_verts = []\n    \n    for p in polygons:\n        v = p.vertices\n        if len(v) < 3: continue\n        # Simple fan triangulation for convex polygons (BSP produces convex polygons)\n        # (v0, v1, v2), (v0, v2, v3), ...\n        for i in range(1, len(v) - 1):\n            all_tri_verts.append(v[0])\n            all_tri_verts.append(v[i])\n            all_tri_verts.append(v[i+1])\n            \n    if not all_tri_verts:\n         return {'vertices': [], 'faces': []}\n\n    # Convert to numpy array\n    all_tri_verts = np.array(all_tri_verts)\n    \n    # Vertex Welding using numpy unique (Scalability optimization)\n    # Rounding to handle float precision issues\n    decimals = 5\n    rounded_verts = np.round(all_tri_verts, decimals=decimals)\n    \n    # unique_verts are the unique rows, indices map original array to unique array\n    # This is much faster than dict hashing for millions of points\n    _, indices = np.unique(rounded_verts, axis=0, return_inverse=True)\n    \n    # The actual vertices to return (use original precision, but picked based on unique)\n    # We need to map back to original unrounded data. \n    # np.unique sorts the data, so we need to be careful.\n    # Better approach: return_index=True gives index of first occurrence\n    u_verts, u_idx, inverse = np.unique(rounded_verts, axis=0, return_index=True, return_inverse=True)\n    final_vertices = all_tri_verts[u_idx]\n    \n    # Reshape indices into faces\n    final_faces = inverse.reshape(-1, 3)\n    \n    return {\n        'vertices': final_vertices.tolist(),\n        'faces': final_faces.tolist()\n    }\n\ndef csg_union(mesh_a, mesh_b):\n    # 1. Pre-check: Input validation and Numpy conversion\n    va = np.array(mesh_a['vertices'])\n    vb = np.array(mesh_b['vertices'])\n    \n    # 2. Broad Phase: AABB Intersection Test\n    min_a, max_a = get_aabb(va)\n    min_b, max_b = get_aabb(vb)\n    \n    # Case 1: Disjoint meshes (Adaptive Scalability)\n    if not boxes_intersect(min_a, max_a, min_b, max_b):\n        # Simply merge the meshes without calculation\n        offset = len(va)\n        new_verts = np.vstack((va, vb))\n        new_faces = np.vstack((np.array(mesh_a['faces']), np.array(mesh_b['faces']) + offset))\n        return {\n            'vertices': new_verts.tolist(),\n            'faces': new_faces.tolist()\n        }\n\n    # Case 2: Intersecting meshes\n    # Optimization: Only process faces that are within the intersection box\n    # Intersection box:\n    int_min = np.maximum(min_a, min_b) - 0.1 # padding\n    int_max = np.minimum(max_a, max_b) + 0.1\n    \n    def is_in_box(verts, min_p, max_p):\n        # A face is 'active' if any vertex is inside the box or spans it.\n        # Simplified: Check if bounding box of face intersects intersection box\n        f_min = np.min(verts, axis=0)\n        f_max = np.max(verts, axis=0)\n        return boxes_intersect(f_min, f_max, min_p, max_p)\n\n    # Convert to Polygons\n    polys_a = mesh_to_polygons(mesh_a)\n    polys_b = mesh_to_polygons(mesh_b)\n    \n    # Filter Active vs Passive Polygons\n    active_a, passive_a = [], []\n    active_b, passive_b = [], []\n    \n    for p in polys_a:\n        if is_in_box(p.vertices, int_min, int_max):\n            active_a.append(p)\n        else:\n            passive_a.append(p)\n            \n    for p in polys_b:\n        if is_in_box(p.vertices, int_min, int_max):\n            active_b.append(p)\n        else:\n            passive_b.append(p)\n            \n    # 3. BSP Operations on Active Subsets\n    if not active_a or not active_b:\n        # Edge case: boxes overlap but faces don't quite touch in the zone\n        # Fallback to simple merge\n        return {\n            'vertices': np.vstack((va, vb)).tolist(),\n            'faces': np.vstack((np.array(mesh_a['faces']), np.array(mesh_b['faces']) + len(va))).tolist()\n        }\n\n    # Build Trees\n    a = BSPNode(active_a)\n    b = BSPNode(active_b)\n    \n    # Clip to each other\n    # Union(A, B) Logic:\n    # 1. Clip A to B (remove parts of A inside B)\n    # 2. Clip B to A (remove parts of B inside A)\n    # 3. Invert B? \n    # The standard algorithm for Union(a,b):\n    # a.clipTo(b)\n    # b.clipTo(a)\n    # b.invert()\n    # b.clipTo(a)\n    # b.invert()\n    # a.build(b.allPolygons())\n    \n    a.clip_to(b)\n    b.clip_to(a)\n    b.invert()\n    b.clip_to(a)\n    b.invert()\n    \n    # Collect results\n    result_polys = a.all_polygons() + b.all_polygons()\n    \n    # Add back the passive polygons (those outside the intersection zone)\n    # Passive A: Definitely outside B (since outside intersection box)\n    # Passive B: Definitely outside A\n    result_polys.extend(passive_a)\n    result_polys.extend(passive_b)\n    \n    # 4. Reconstruct and Weld\n    return reconstruct_mesh(result_polys)\n"}