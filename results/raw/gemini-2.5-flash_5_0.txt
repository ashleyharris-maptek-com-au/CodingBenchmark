{'reasoning': "The Hamiltonian Path problem on a 2D grid with obstacles is NP-complete, meaning no polynomial-time algorithm is known for all instances. For the given constraints (up to 50x50 grids, 2500 cells, 5-minute time limit, standard library only), a simple brute-force backtracking (Depth-First Search) would be too slow. Therefore, the core strategy must be a highly optimized backtracking algorithm with aggressive pruning techniques and heuristics.\n\nMy approach adapts to different grid sizes by uniformly applying the most effective pruning strategies, which implicitly adjust their impact based on the problem's complexity:\n\n1.  **Core Algorithm: Depth-First Search (DFS) with Backtracking:** This is the foundational method. It explores potential paths by moving to adjacent unvisited, non-obstacle cells. If a path leads to a dead end, it backtracks.\n\n2.  **Early Exit Conditions:**\n    *   If `(0, 0)` is an obstacle, no path can start, so return `[]` immediately.\n    *   If there are no non-obstacle cells, or only `(0, 0)` is a non-obstacle and a cycle is required, return `[]`.\n    *   **Parity Check for Cycles:** Grid graphs are bipartite. A Hamiltonian cycle in a bipartite graph must contain an even number of vertices. If `require_cycle` is `True` and the total number of non-obstacle cells (`num_cells_to_visit`) is odd, it's impossible to form a cycle, so return `[]`.\n\n3.  **Heuristic for Next Move Selection (Warnsdorff's Rule Adaptation):**\n    *   At each step, instead of trying neighbors in a fixed order, potential next cells are sorted. The heuristic prioritizes moving to cells that have the fewest unvisited neighbors (excluding the current path and the `next_node` itself). The idea is to 'save' cells with many connections for later, reducing the chance of isolating parts of the graph too early. This guides the DFS towards more promising paths and prunes less promising branches earlier.\n\n4.  **Critical Pruning: Connectivity Check:**\n    *   Before making a move to `next_node`, the algorithm performs a connectivity check on the *remaining unvisited, non-obstacle cells* (excluding `next_node` and cells already in the path). If these remaining cells do not form a single connected component, then moving to `next_node` would trap some cells, making a Hamiltonian path impossible. This branch is immediately pruned.\n    *   This check is performed using a Breadth-First Search (BFS) on the subgraph of remaining unvisited cells. It has `O(N)` complexity (where N is the number of remaining cells). While expensive, it's crucial for avoiding exponentially many futile paths. The `len(remaining_future_unvisited_cells) > 1` condition ensures this expensive check is not run if the path is almost complete.\n    *   The `_check_connectivity` helper function picks an arbitrary cell from the `remaining_future_unvisited_cells` and runs a BFS to count reachable cells within that set. If the count does not match the total size of `remaining_future_unvisited_cells`, it means the graph is disconnected, and the move is invalid.\n\n**Scalability Considerations:**\n*   For **small grids** (e.g., 4x4 to 10x10): The full DFS with connectivity pruning and Warnsdorff's heuristic is highly effective and finds paths quickly. The `O(N)` connectivity check is fast enough for small `N`.\n*   For **medium to large grids** (e.g., 10x10 to 50x50): The algorithm's performance heavily relies on the effectiveness of the pruning. If a path exists and the heuristics guide the search efficiently, many branches will be pruned early by the connectivity check or by leading to dead ends. The `_check_connectivity` (O(N) per DFS step) means that if the effective branching factor is low, the total complexity can approach `O(N^2)` or `O(N^3)` in practice, which can be acceptable for `N=2500` if the constants are small and the search space is constrained. The worst-case `N^4` for unpruned exponential branches will not pass.\n*   The provided solution applies these pruning strategies universally, as a single adaptive function, rather further optimizing beyond core pruning. The *efficiency* of the pruning itself becomes adaptive; it cuts off larger subproblems more effectively on larger grids.\n\nThe combination of these techniques makes the algorithm robust and capable of handling a wide range of grid sizes within the specified time limits, as is common practice for contest-style Hamiltonian Path problems on grids where full exponential solutions are not feasible.", 'python_code': "import collections\n\ndef find_hamiltonian_path(width, height, obstacles, require_cycle):\n    # Helper to get valid neighbors within grid bounds\n    def _get_neighbors(r, c, w, h):\n        neighbors = []\n        if r > 0: neighbors.append((r - 1, c))\n        if r < h - 1: neighbors.append((r + 1, c))\n        if c > 0: neighbors.append((r, c - 1))\n        if c < w - 1: neighbors.append((r, c + 1))\n        return neighbors\n\n    # Helper to count unvisited neighbors for Warnsdorff's Rule heuristic\n    def _count_unvisited_neighbors(cell, current_visited_set, w, h, non_obstacle_cells_set):\n        r, c = cell\n        count = 0\n        for nr, nc in _get_neighbors(r, c, w, h):\n            neighbor = (nr, nc)\n            if neighbor in non_obstacle_cells_set and neighbor not in current_visited_set:\n                count += 1\n        return count\n\n    # Helper to check if remaining unvisited cells form a connected component\n    def _check_connectivity(start_node_for_bfs, remaining_cells_set, w, h):\n        if not remaining_cells_set: # No cells left to check, trivially connected\n            return True\n        if len(remaining_cells_set) == 1: # Only one cell left, trivially connected\n            return True\n\n        # Ensure start_node_for_bfs is actually one of the remaining cells\n        if start_node_for_bfs not in remaining_cells_set:\n             # This case should ideally not happen if logic is correct, but for robustness\n            start_node_for_bfs = next(iter(remaining_cells_set))\n\n        visited_bfs = {start_node_for_bfs}\n        queue = collections.deque([start_node_for_bfs])\n        count = 0\n\n        while queue:\n            r, c = queue.popleft()\n            count += 1\n            for nr, nc in _get_neighbors(r, c, w, h):\n                neighbor = (nr, nc)\n                if neighbor in remaining_cells_set and neighbor not in visited_bfs:\n                    visited_bfs.add(neighbor)\n                    queue.append(neighbor)\n\n        return count == len(remaining_cells_set)\n\n    # --- Main function logic ---\n\n    start_node = (0, 0)\n\n    # Convert obstacles to a set for O(1) lookups\n    obstacles_set = set(obstacles)\n\n    # Initial checks\n    if start_node in obstacles_set:\n        return [] # Cannot start at an obstacle\n\n    all_cells = {(r, c) for r in range(height) for c in range(width)}\n    non_obstacle_cells = all_cells - obstacles_set\n    num_cells_to_visit = len(non_obstacle_cells)\n\n    if num_cells_to_visit == 0:\n        return [] # No cells to visit\n\n    # Special case: only one non-obstacle cell\n    if num_cells_to_visit == 1:\n        if require_cycle:\n            return [] # Cannot form a cycle with one cell\n        else:\n            if start_node in non_obstacle_cells:\n                return [start_node]\n            else:\n                return [] # This condition should already be covered by start_node in obstacles_set\n\n    # Parity check for cycles on bipartite graphs (grid graphs are bipartite)\n    # A Hamiltonian cycle in a bipartite graph must have an even number of vertices.\n    if require_cycle and num_cells_to_visit % 2 != 0:\n        return []\n\n    path = [start_node]\n    visited = {start_node}\n\n    # DFS function for backtracking search\n    def _dfs(current_node):\n        nonlocal path, visited # Allow modification of path and visited from outer scope\n\n        if len(path) == num_cells_to_visit:\n            # Path complete, check cycle requirement\n            if require_cycle:\n                if start_node in _get_neighbors(current_node[0], current_node[1], width, height):\n                    return list(path) # Found a cycle\n                else:\n                    return None # Path complete but not a cycle\n            else:\n                return list(path) # Found a path\n\n        # Prepare neighbors for the current_node\n        neighbors_to_consider = []\n        for nr, nc in _get_neighbors(current_node[0], current_node[1], width, height):\n            next_node = (nr, nc)\n            if next_node in non_obstacle_cells and next_node not in visited:\n                neighbors_to_consider.append(next_node)\n\n        # Sort neighbors using Warnsdorff's Rule heuristic:\n        # Prioritize cells with fewer unvisited neighbors. This often helps guide the search.\n        # We count neighbors as if 'next_node' is already visited.\n        neighbors_to_consider.sort(key=lambda n: _count_unvisited_neighbors(n, visited | {n}, width, height, non_obstacle_cells))\n\n        for next_node in neighbors_to_consider:\n            # Pruning 1: Connectivity Check\n            # After hypothetically adding next_node, check if the remaining unvisited cells are still connected.\n            # This is a crucial pruning step for performance on larger grids.\n            remaining_future_unvisited_cells = non_obstacle_cells - (visited | {next_node})\n\n            # Perform the expensive connectivity check only if there are multiple cells remaining to visit.\n            # If 0 or 1 cell remains, connectivity is trivially maintained (or handled by the base case).\n            if len(remaining_future_unvisited_cells) > 1:\n                arbitrary_unvisited_cell = next(iter(remaining_future_unvisited_cells))\n                if not _check_connectivity(arbitrary_unvisited_cell, remaining_future_unvisited_cells, width, height):\n                    continue # This move would disconnect the graph, so skip it\n\n            # If valid, add to path and recurse\n            path.append(next_node)\n            visited.add(next_node)\n\n            result = _dfs(next_node)\n            if result is not None:\n                return result\n\n            # Backtrack\n            visited.remove(next_node)\n            path.pop()\n\n        return None # No path found from current_node\n\n    return _dfs(start_node)\n"}