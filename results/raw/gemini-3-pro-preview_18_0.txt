{'reasoning': "The solution employs a hybrid adaptive strategy to handle varying graph scales efficiently under the 32GB memory constraint. \n\n1. **Data Structure**: We store the graph as a flat Edge List (`vector<struct Edge>`) to minimize memory overhead (8 bytes per edge), allowing graphs with billions of edges to fit in RAM. Fast I/O is used to parse large inputs quickly.\n\n2. **Algorithm Selection based on N**:\n   - **Small/Medium Graphs (N <= 600)**: We use the **Stoer-Wagner algorithm**. It is deterministic and finds the exact global minimum cut. We convert the edge list to a dense Adjacency Matrix for this phase, enabling efficient O(N^3) merging operations.\n   - **Large/Massive Graphs (N > 600)**: O(N^3) is computationally infeasible. We switch to a **Randomized Karger's Algorithm**. To ensure a high-quality baseline, we first calculate the **Minimum Degree Cut**, which is often the global minimum for large real-world networks. Then, we run Karger's contraction multiple times within a time budget (approx. 1.8s) to search for smaller cuts. This approach balances speed and accuracy for massive datasets where exact deterministic global min-cut is impractical.\n\n3. **Corner Cases**: Connectivity is checked via Union-Find (DSU) initially; if the graph is disconnected, the cut is 0.", 'cpp_code': '#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <chrono>\n#include <cstring>\n\nclass FastIO {\npublic:\n    FastIO() {\n        std::ios_base::sync_with_stdio(false);\n        std::cin.tie(NULL);\n    }\n} fast_io;\n\nstruct Edge {\n    int u, v;\n};\n\nstruct DSU {\n    std::vector<int> parent;\n    int components;\n    DSU(int n) : parent(n), components(n) {\n        std::iota(parent.begin(), parent.end(), 0);\n    }\n    int find(int i) {\n        if (parent[i] == i) return i;\n        return parent[i] = find(parent[i]);\n    }\n    bool unite(int i, int j) {\n        int root_i = find(i);\n        int root_j = find(j);\n        if (root_i != root_j) {\n            parent[root_i] = root_j;\n            components--;\n            return true;\n        }\n        return false;\n    }\n};\n\nint best_cut_size = 2147483647;\nstd::vector<int> best_partition;\nint N; \nlong long M;\nstd::vector<Edge> all_edges;\nstd::vector<int> degrees;\n\nvoid solve_stoer_wagner() {\n    std::vector<int> adj(N * N, 0);\n    for (const auto& e : all_edges) {\n        if (e.u != e.v) {\n            adj[e.u * N + e.v]++;\n            adj[e.v * N + e.u]++;\n        }\n    }\n    std::vector<std::vector<int>> co_nodes(N);\n    for(int i=0; i<N; ++i) co_nodes[i].push_back(i);\n    std::vector<bool> exists(N, true);\n    int cnt_nodes = N;\n    while (cnt_nodes > 1) {\n        int a = -1;\n        for(int i=0; i<N; ++i) if(exists[i]) { a = i; break; }\n        std::vector<int> weights(N, 0);\n        std::vector<bool> in_A(N, false);\n        in_A[a] = true;\n        int prev = a;\n        int curr = a;\n        for (int step = 1; step < cnt_nodes; ++step) {\n            for(int i=0; i<N; ++i) {\n                if(exists[i] && !in_A[i]) {\n                    weights[i] += adj[curr * N + i];\n                }\n            }\n            int max_w = -1;\n            int next_node = -1;\n            for(int i=0; i<N; ++i) {\n                if(exists[i] && !in_A[i]) {\n                    if (weights[i] > max_w) {\n                        max_w = weights[i];\n                        next_node = i;\n                    }\n                }\n            }\n            prev = curr;\n            curr = next_node;\n            in_A[curr] = true;\n        }\n        if (weights[curr] < best_cut_size) {\n            best_cut_size = weights[curr];\n            std::fill(best_partition.begin(), best_partition.end(), 0);\n            for(int node_idx : co_nodes[curr]) {\n                best_partition[node_idx] = 1;\n            }\n        }\n        for(int i=0; i<N; ++i) {\n            if (i != prev && i != curr && exists[i]) {\n                adj[prev * N + i] += adj[curr * N + i];\n                adj[i * N + prev] += adj[curr * N + i];\n            }\n        }\n        co_nodes[prev].insert(co_nodes[prev].end(), co_nodes[curr].begin(), co_nodes[curr].end());\n        exists[curr] = false;\n        cnt_nodes--;\n    }\n}\n\nvoid solve_karger() {\n    std::vector<int> indices(M);\n    std::iota(indices.begin(), indices.end(), 0);\n    std::mt19937 rng(std::random_device{}());\n    auto start = std::chrono::steady_clock::now();\n    while (true) {\n        auto now = std::chrono::steady_clock::now();\n        if (std::chrono::duration_cast<std::chrono::milliseconds>(now - start).count() > 1800) break;\n        std::shuffle(indices.begin(), indices.end(), rng);\n        DSU dsu(N);\n        for (int idx : indices) {\n            if (dsu.components <= 2) break;\n            dsu.unite(all_edges[idx].u, all_edges[idx].v);\n        }\n        if (dsu.components > 2) { best_cut_size = 0; return; }\n        int cut_val = 0;\n        for (const auto& e : all_edges) {\n            if (dsu.find(e.u) != dsu.find(e.v)) {\n                cut_val++;\n                if (cut_val >= best_cut_size) break;\n            }\n        }\n        if (cut_val < best_cut_size) {\n            best_cut_size = cut_val;\n            int r0 = dsu.find(0);\n            for(int i=0; i<N; ++i) best_partition[i] = (dsu.find(i) == r0) ? 0 : 1;\n        }\n    }\n}\n\nint main() {\n    if (!(std::cin >> N >> M)) return 0;\n    if (N < 2) {\n        std::cout << "0\\n";\n        return 0;\n    }\n    all_edges.reserve(M);\n    degrees.assign(N, 0);\n    best_partition.assign(N, 0);\n    for (long long i = 0; i < M; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        all_edges.push_back({u, v});\n        degrees[u]++;\n        degrees[v]++;\n    }\n    int min_deg = 2147483647;\n    int min_node = -1;\n    for (int i = 0; i < N; ++i) {\n        if (degrees[i] < min_deg) {\n            min_deg = degrees[i];\n            min_node = i;\n        }\n    }\n    best_cut_size = min_deg;\n    if (min_node != -1) best_partition[min_node] = 1;\n    if (min_deg == 0) {\n        std::cout << "0\\n";\n        return 0;\n    }\n    DSU check(N);\n    for(const auto& e : all_edges) check.unite(e.u, e.v);\n    if(check.components > 1) {\n        std::cout << "0\\n";\n        return 0;\n    }\n    if (N <= 600) solve_stoer_wagner();\n    else solve_karger();\n    std::cout << best_cut_size << "\\n";\n    for (const auto& e : all_edges) {\n        if (best_partition[e.u] != best_partition[e.v]) {\n            std::cout << e.u << " " << e.v << "\\n";\n        }\n    }\n    return 0;\n}'}