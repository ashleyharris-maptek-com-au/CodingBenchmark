{'reasoning': 'The solution employs an adaptive strategy for the Orbital TSP. For a small number of stations (<= 8), it uses brute-force permutation to find the exact optimal path, as the combinatorial explosion is manageable. For medium to large numbers of stations (9 to 30), it switches to a greedy nearest-neighbor heuristic combined with 2-opt local search for optimization. For very large numbers of stations (> 30), it leverages a simulated annealing algorithm. This approach balances solution accuracy with computational feasibility across different scales. The core of delta-V calculation for transfers between orbits is approximated by Hohmann transfers for simplicity and efficiency, acknowledging that more complex transfers might yield slightly better results but at a significant computational cost, especially for many stations. The function prioritizes a runnable and scalable solution that adheres to the constraints.', 'python_code': 'import math\nimport itertools\nimport random\n\ndef norm(v):\n    return math.sqrt(sum(x*x for x in v))\n\ndef subtract_vectors(v1, v2):\n    return [v1[i] - v2[i] for i in range(3)]\n\ndef cross_product(v1, v2):\n    return [\n        v1[1]*v2[2] - v1[2]*v2[1],\n        v1[2]*v2[0] - v1[0]*v2[2],\n        v1[0]*v2[1] - v1[1]*v2[0]\n    ]\n\ndef dot_product(v1, v2):\n    return sum(v1[i] * v2[i] for i in range(3))\n\ndef scale_vector(v, scalar):\n    return [x * scalar for x in v]\n\ndef add_vectors(v1, v2):\n    return [v1[i] + v2[i] for i in range(3)]\n\ndef get_orbital_elements(r_vec, v_vec, mu):\n    r = norm(r_vec)\n    v = norm(v_vec)\n    h_vec = cross_product(r_vec, v_vec)\n    h = norm(h_vec)\n    i = math.acos(h_vec[2] / h) if h != 0 else 0\n    n_vec = [h_vec[1]/h, -h_vec[0]/h, 0]\n    if norm(n_vec) == 0:\n        e_vec = subtract_vectors(cross_product(v_vec, h_vec), scale_vector(r_vec, mu/r))\n    else:\n        e_vec = subtract_vectors(cross_product(v_vec, h_vec), scale_vector(r_vec, mu/r))\n    e = norm(e_vec)\n    if e == 0:\n        a = r * v**2 / (2*mu) - v**2 / 2\n    else:\n        a = (v**2/2 - mu/r) / (1 - e**2)\n    return {\n        \'r\': r,\n        \'v\': v,\n        \'h\': h,\n        \'i\': i,\n        \'n_vec\': n_vec,\n        \'e_vec\': e_vec,\n        \'e\': e,\n        \'a\': a\n    }\n\ndef hohmann_transfer_delta_v(orbit1_a, orbit2_a):\n    if orbit1_a == orbit2_a:\n        return 0.0\n    v1 = math.sqrt(mu / orbit1_a)\n    v2 = math.sqrt(mu / orbit2_a)\n    a_transfer = (orbit1_a + orbit2_a) / 2\n    dv1 = abs(math.sqrt(mu / orbit1_a) * (math.sqrt(2 * orbit2_a / (orbit1_a + orbit2_a)) - 1))\n    dv2 = abs(math.sqrt(mu / orbit2_a) * (math.sqrt(2 * orbit1_a / (orbit1_a + orbit2_a)) - 1))\n    return dv1 + dv2\n\ndef delta_v_between_states(state1, state2, mu):\n    # Simplified delta-V estimation between two orbital states.\n    # Assumes impulsive burns and considers change in velocity vector magnitude for simplicity.\n    # A more accurate method would involve Lambert\'s problem or patched conics for transfers.\n    # For this simplified TSP, we\'ll use a proxy based on orbital energy (semi-major axis).\n    elements1 = get_orbital_elements(state1[:3], state1[3:], mu)\n    elements2 = get_orbital_elements(state2[:3], state2[3:], mu)\n\n    # If inclinations are very different, a significant delta-v is required.\n    # This is a simplification, as plane change maneuvers are complex.\n    inclination_diff = abs(elements1[\'i\'] - elements2[\'i\']) * 180 / math.pi\n    plane_change_dv = 0\n    if inclination_diff > 1.0:\n        # Crude approximation: Delta-v for plane change is roughly 2 * V * sin(angle/2)\n        # This is highly inaccurate but provides a factor.\n        plane_change_dv = 2 * elements1[\'v\'] * math.sin(math.radians(inclination_diff)/2) * 0.5 # Factor of 0.5 for approximation\n\n    # Hohmann transfer delta-v between the semi-major axes.\n    # This is a primary component for changing altitude.\n    altitude_transfer_dv = hohmann_transfer_delta_v(elements1[\'a\'], elements2[\'a\'])\n\n    # Combine DV components. This is a rough estimate.\n    # A more robust solution would calculate specific transfer orbits.\n    return altitude_transfer_dv + plane_change_dv\n\ndef calculate_total_delta_v(path_states, mu):\n    total_dv = 0.0\n    for i in range(len(path_states) - 1):\n        total_dv += delta_v_between_states(path_states[i], path_states[i+1], mu)\n    return total_dv\n\ndef solve_orbital_tsp(start_orbit, station_orbits, mu):\n    num_stations = len(station_orbits)\n    station_indices = list(range(num_stations))\n\n    # Store orbital elements for efficiency\n    all_states = [start_orbit] + station_orbits\n    all_orbital_elements = [get_orbital_elements(state[:3], state[3:], mu) for state in all_states]\n\n    best_order = []\n    min_delta_v = float(\'inf\')\n\n    if num_stations <= 8:  # Brute-force for small N\n        for perm in itertools.permutations(station_indices):\n            current_order = list(perm)\n            path_states = [start_orbit] + [station_orbits[i] for i in current_order]\n            current_delta_v = calculate_total_delta_v(path_states, mu)\n\n            if current_delta_v < min_delta_v:\n                min_delta_v = current_delta_v\n                best_order = current_order\n\n    elif num_stations <= 20: # Nearest Neighbor + 2-Opt for medium N\n        # Nearest Neighbor initialization\n        unvisited = set(station_indices)\n        current_index = -1 # -1 represents the start orbit\n        current_order = []\n        \n        while unvisited:\n            nearest_neighbor_idx = -1\n            min_dist = float(\'inf\')\n            current_state = start_orbit if current_index == -1 else station_orbits[current_index]\n\n            for neighbor_idx in unvisited:\n                dist = delta_v_between_states(current_state, station_orbits[neighbor_idx], mu)\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_neighbor_idx = neighbor_idx\n            \n            current_order.append(nearest_neighbor_idx)\n            unvisited.remove(nearest_neighbor_idx)\n            current_index = nearest_neighbor_idx\n        \n        # 2-Opt Local Search\n        improved = True\n        while improved:\n            improved = False\n            for i in range(len(current_order) - 1):\n                for j in range(i + 1, len(current_order)):\n                    new_order = current_order[:i] + current_order[i:j+1][::-1] + current_order[j+1:]\n                    \n                    path_states_original = [start_orbit] + [station_orbits[idx] for idx in current_order]\n                    path_states_new = [start_orbit] + [station_orbits[idx] for idx in new_order]\n\n                    dv_original = calculate_total_delta_v(path_states_original, mu)\n                    dv_new = calculate_total_delta_v(path_states_new, mu)\n\n                    if dv_new < dv_original:\n                        current_order = new_order\n                        improved = True\n        best_order = current_order\n        min_delta_v = calculate_total_delta_v([start_orbit] + [station_orbits[i] for i in best_order], mu)\n\n    else: # Simulated Annealing for large N\n        # Initial solution (greedy nearest neighbor)\n        unvisited = set(station_indices)\n        current_index = -1\n        current_order = []\n        \n        while unvisited:\n            nearest_neighbor_idx = -1\n            min_dist = float(\'inf\')\n            current_state = start_orbit if current_index == -1 else station_orbits[current_index]\n\n            for neighbor_idx in unvisited:\n                dist = delta_v_between_states(current_state, station_orbits[neighbor_idx], mu)\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_neighbor_idx = neighbor_idx\n            \n            current_order.append(nearest_neighbor_idx)\n            unvisited.remove(nearest_neighbor_idx)\n            current_index = nearest_neighbor_idx\n        \n        best_order = list(current_order)\n        min_delta_v = calculate_total_delta_v([start_orbit] + [station_orbits[i] for i in best_order], mu)\n\n        # Simulated Annealing Parameters\n        initial_temp = 10000\n        cooling_rate = 0.995\n        num_iterations = 5000\n        \n        current_temp = initial_temp\n\n        for iteration in range(num_iterations):\n            if current_temp < 1e-3:\n                break\n\n            # Generate a neighboring solution by swapping two cities\n            neighbor_order = list(current_order)\n            idx1, idx2 = random.sample(range(num_stations), 2)\n            neighbor_order[idx1], neighbor_order[idx2] = neighbor_order[idx2], neighbor_order[idx1]\n\n            current_path_states = [start_orbit] + [station_orbits[i] for i in current_order]\n            neighbor_path_states = [start_orbit] + [station_orbits[i] for i in neighbor_order]\n\n            current_cost = calculate_total_delta_v(current_path_states, mu)\n            neighbor_cost = calculate_total_delta_v(neighbor_path_states, mu)\n\n            delta_cost = neighbor_cost - current_cost\n\n            if delta_cost < 0 or random.random() < math.exp(-delta_cost / current_temp):\n                current_order = list(neighbor_order)\n                current_cost = neighbor_cost\n\n            if current_cost < min_delta_v:\n                min_delta_v = current_cost\n                best_order = list(current_order)\n\n            current_temp *= cooling_rate\n\n    # Ensure station indices are correctly mapped if not all stations are visited\n    # (This implementation assumes all stations in the subset must be visited)\n\n    return {\n        "visit_order": best_order,\n        "total_delta_v": min_delta_v,\n        "reasoning": "Adaptive strategy: Brute-force for <=8 stations, Nearest Neighbor + 2-Opt for 9-20, Simulated Annealing for >20. Delta-V estimated using simplified orbital mechanics (Hohmann-like transfers with inclination approximations)."\n    }\n\n# Example Usage (Optional - for testing purposes)\n# mu_earth = 398600.4418\n# start_state = [-1846.0, -6653.9, -3451.3, 4.306, 1.937, -5.512]\n# \n# # Define a few sample station orbits (these would be more realistic in a real scenario)\n# # Example: Geostationary, Molniya, polar, LEO orbits\n# station_1 = [7150, 0, 0, 0, 8.07, 0] # ~GEO altitude\n# station_2 = [-7150, 0, 0, 0, -8.07, 0] # Opposite GEO\n# station_3 = [0, 7150, 0, -8.07, 0, 0] # GEO shifted\n# station_4 = [10000, 10000, 0, -5.7, -5.7, 0] # Higher eliptical\n# station_5 = [0, 0, 8000, 0, 0, 7.1] # Polar like\n# station_6 = [7000, 0, 0, 0, 7.5, 0] \n# station_7 = [0, 7000, 0, -7.5, 0, 0]\n# station_8 = [-7000, 0, 0, 0, -7.5, 0]\n# station_9 = [0, -7000, 0, 7.5, 0, 0]\n# station_10 = [8000, 0, 0, 0, 7.1, 0]\n# \n# all_stations = [\n#     station_1, station_2, station_3, station_4, station_5,\n#     station_6, station_7, station_8, station_9, station_10\n# ]\n# \n# # Test with different numbers of stations\n# print("--- 3 Stations ---")\n# result_3 = solve_orbital_tsp(start_state, all_stations[:3], mu_earth)\n# print(result_3)\n# \n# print("\\n--- 8 Stations ---")\n# result_8 = solve_orbital_tsp(start_state, all_stations[:8], mu_earth)\n# print(result_8)\n# \n# print("\\n--- 15 Stations ---")\n# result_15 = solve_orbital_tsp(start_state, all_stations[:15], mu_earth) # Note: We only defined 10, so this will use 10.\n# print(result_15)\n# \n# print("\\n--- 50 Stations (using 10 for demo) ---")\n# result_50 = solve_orbital_tsp(start_state, all_stations, mu_earth)\n# print(result_50)\n'}