{'reasoning': "The solution implements an adaptive strategy based on the input size N. For Small/Medium scales (N <= 3000), an O(N^2) Greedy Nearest Neighbor approach initializes a good path, followed by a 2-Opt local search to refine it. This ensures high-quality routes for manageable sizes. For Large/Extreme scales (N > 3000), O(N^2) is too slow, so an O(N log N) 'Strip Decomposition' (Snake Sort) is used. This method sorts cities by X-coordinate, partitions them into vertical strips, and then sorts each strip by Y-coordinate (alternating ascending/descending) to maintain locality. This approach relies on Python's highly optimized Timsort (written in C) to handle even 10 million cities efficiently within the time limit and memory constraints.", 'python_code': 'import math\n\ndef solve_tsp(cities):\n    """\n    Solves the TSP using an adaptive strategy based on problem scale.\n    \n    Strategy:\n    1. N <= 3000: Greedy Nearest Neighbor + 2-Opt (O(N^2))\n       - High quality, feasible runtime for small/medium inputs.\n    2. N > 3000: Strip Decomposition / Snake Sort (O(N log N))\n       - Very fast approximation relying on sorting locality.\n       - Handles up to 10M cities efficiently.\n    """\n    N = len(cities)\n    \n    # Handle edge cases\n    if N == 0:\n        return []\n    if N == 1:\n        return [0]\n    \n    # Adaptive Threshold\n    # N=3000 implies ~9M distance calculations, taking ~1-2s in Python.\n    # This leaves ample room for 2-Opt passes within a 30s limit.\n    if N <= 3000:\n        return _solve_greedy_2opt(cities)\n    else:\n        return _solve_strip_decomposition(cities)\n\ndef _solve_greedy_2opt(cities):\n    N = len(cities)\n    # 1. Greedy Nearest Neighbor Initialization\n    # Start at city 0\n    route = [0]\n    unvisited = set(range(1, N))\n    current = 0\n    \n    while unvisited:\n        # Find nearest unvisited city\n        # In pure Python, an explicit loop is often faster than min() with lambda for simple math\n        cx, cy = cities[current]\n        best_dist = float(\'inf\')\n        nearest = -1\n        \n        for candidate in unvisited:\n            ux, uy = cities[candidate]\n            dist = (cx - ux)**2 + (cy - uy)**2\n            if dist < best_dist:\n                best_dist = dist\n                nearest = candidate\n        \n        route.append(nearest)\n        unvisited.remove(nearest)\n        current = nearest\n\n    # 2. 2-Opt Local Search Optimization\n    # Limit passes to ensure we stay well within time limits\n    max_passes = 3\n    improved = True\n    \n    for _ in range(max_passes):\n        if not improved:\n            break\n        improved = False\n        \n        # Iterate through edges to find swaps\n        for i in range(N - 2):\n            p1 = route[i]\n            p2 = route[i+1]\n            x1, y1 = cities[p1]\n            x2, y2 = cities[p2]\n            \n            # We look for a second edge (j, j+1) to swap with (i, i+1)\n            # We skip j=N-1 (wrapping edge) to simplify logic and keep route[0] fixed\n            for j in range(i + 2, N - 1):\n                p3 = route[j]\n                p4 = route[j+1]\n                x3, y3 = cities[p3]\n                x4, y4 = cities[p4]\n                \n                # Current distance: (p1->p2) + (p3->p4)\n                d_curr = ((x1-x2)**2 + (y1-y2)**2) + ((x3-x4)**2 + (y3-y4)**2)\n                \n                # New distance after 2-opt swap: (p1->p3) + (p2->p4)\n                d_new = ((x1-x3)**2 + (y1-y3)**2) + ((x2-x4)**2 + (y2-y4)**2)\n                \n                if d_new < d_curr:\n                    # Perform the swap: reverse segment route[i+1...j]\n                    route[i+1 : j+1] = route[i+1 : j+1][::-1]\n                    improved = True\n                    # Optimization: break inner loop or continue? \n                    # Continuing finds more swaps in one pass.\n                    \n    return route\n\ndef _solve_strip_decomposition(cities):\n    """\n    Solves TSP for large N by sorting cities into vertical strips.\n    Complexity: O(N log N) dominated by sorting.\n    """\n    N = len(cities)\n    # We work with indices to avoid duplicating coordinate data in memory for huge N\n    indices = list(range(N))\n    \n    # 1. Sort all cities by X-coordinate\n    # list.sort is Timsort (highly optimized C implementation)\n    indices.sort(key=lambda i: cities[i][0])\n    \n    # 2. Decompose into vertical strips\n    # Heuristic: sqrt(N) strips provides a good balance between X and Y travel\n    num_strips = int(math.sqrt(N))\n    if num_strips < 1: \n        num_strips = 1\n        \n    chunk_size = (N + num_strips - 1) // num_strips\n    final_route = []\n    \n    for k in range(num_strips):\n        start = k * chunk_size\n        end = min(start + chunk_size, N)\n        \n        if start >= N:\n            break\n            \n        # Extract the strip\n        strip = indices[start:end]\n        \n        # 3. Sort strip by Y-coordinate\n        # Alternating direction (Ascending/Descending) creates a snake-like path\n        # reducing the jump cost between strips.\n        if k % 2 == 0:\n            strip.sort(key=lambda i: cities[i][1])\n        else:\n            strip.sort(key=lambda i: cities[i][1], reverse=True)\n            \n        final_route.extend(strip)\n        \n    return final_route'}