{'reasoning': "The 2D Polygon Cutting Stock Problem is NP-hard, making optimal solutions intractable for large-scale inputs. My approach leverages a combination of a greedy heuristic, adaptive search strategies, and robust geometric primitives implemented with NumPy to balance performance, solution quality, and scalability.\n\n**1. Adaptive Strategy for Scalability:**\n   The core challenge is the varying problem complexity (from 2 simple pieces to 10000+ complex polygons). To address this, I've implemented an adaptive configuration (`THOROUGH_CONFIG`, `FAST_CONFIG`, `VERY_FAST_CONFIG`, `ULTRA_FAST_CONFIG`) that dynamically adjusts search parameters based on the total number of pieces. This allows for a more exhaustive search (finer rotations, more placement points) for smaller problems, gradually scaling down to more aggressive heuristics (coarser rotations, fewer, strategically sampled placement points) for larger, industrial-scale problems.\n\n   - **`num_rotation_angles`**: Reduces the number of discrete rotation angles to check for larger inputs, sacrificing minor rotational optimization for speed.\n   - **`max_translation_points`**: Limits the number of candidate translation points considered for each piece. For smaller problems, it allows a broader exploration of the stock area. For larger problems, it ensures a fixed, manageable computational budget per piece placement attempt.\n   - **`grid_step_size_factor`**: Influences the initial density of candidate placement points. This is balanced with `max_translation_points` to prevent excessively dense grids for large stocks or pieces.\n\n**2. Greedy Best-Fit Placement Heuristic:**\n   The algorithm sorts pieces by decreasing area. This 'largest-first' heuristic is common in packing problems, as it tends to fill large voids efficiently and reduce fragmentation, leaving smaller spaces for smaller pieces. For each piece:\n   - It first attempts to place the piece in existing stocks, prioritizing the 'lowest-leftmost' available position (based on the piece's translated bounding box). This helps consolidate pieces and minimize the overall footprint within a stock.\n   - If no suitable position is found in existing stocks, a new stock is opened, and the piece is placed in its lowest-leftmost corner relative to the new stock's bounding box.\n   This greedy approach aims to minimize the number of stock polygons used, providing a reasonable quality solution for an NP-hard problem within practical time limits.\n\n**3. Robust Geometric Primitives with NumPy:**\n   All core geometric operations are implemented from scratch using NumPy for performance and to adhere to the specified dependency constraints. These include:\n   - **`get_bounding_box`**: Fast initial spatial check.\n   - **`rotate_polygon` & `translate_polygon`**: Efficient affine transformations using NumPy array operations.\n   - **`calculate_polygon_area`**: For sorting pieces.\n   - **`orientation`, `on_segment`, `segments_intersect`**: Fundamental building blocks for robust line segment intersection detection. This is critical for determining overlaps and containment.\n   - **`is_point_in_polygon`**: Implemented using the ray-casting algorithm to check if a point lies within a polygon. This is used in overlap and containment checks.\n   - **`is_point_on_polygon_edge`**: Handles cases where pieces touch boundaries precisely.\n   - **`do_polygons_overlap`**: The most complex collision detection, combining bounding box checks, vertex-in-polygon checks, and edge-intersection checks to accurately determine if two polygons intersect or contain each other.\n   - **`is_polygon_within_stock`**: Verifies that a piece is fully contained within a stock, checking all vertices are inside/on the boundary and no piece edge strictly crosses a stock boundary (using a midpoint check heuristic for speed).\n\n**4. Performance Considerations for 10000+ Pieces:**\n   For extremely large problem instances, the bottleneck is typically the `do_polygons_overlap` and `is_polygon_within_stock` calls, as these involve iterating through edges/vertices. The adaptive strategy significantly prunes the search space by reducing rotations and translation points. Additionally, bounding box checks are performed first in all collision functions to quickly rule out non-overlapping candidates, drastically reducing the number of expensive detailed polygon-polygon checks. The 'lowest-leftmost' scoring coupled with breaking early on `ULTRA_FAST_CONFIG` allows for a fast, albeit potentially less optimal, solution in very tight time constraints.\n\n**Limitations & Trade-offs:**\n   - **Optimality**: As a heuristic, this algorithm does not guarantee a globally optimal solution (minimal stock usage). The 'lowest-leftmost' and 'largest-first' are good general heuristics but can get trapped in local optima.\n   - **Concave Polygons**: While the geometric primitives generally handle concave polygons (e.g., ray casting for point-in-polygon), packing concave shapes optimally is significantly harder. The greedy approach might leave more gaps than an NFP-based method.\n   - **Floating Point Precision**: Geometric operations can suffer from floating-point inaccuracies. While `epsilon` is used for `is_point_on_polygon_edge`, a full robust geometry library would typically handle this more comprehensively.\n   - **Extreme Cases**: For 10000+ pieces with *each* piece having a very large number of vertices (e.g., 100+), the `O(V_avg^2)` complexity of detailed collision checks might still exceed the 5-minute limit, even with aggressive parameter reduction. The current `max_translation_points` and `num_rotation_angles` are set to be highly restrictive in such scenarios to prioritize completion over quality.", 'python_code': 'import numpy as np\nimport math\n\n# --- Geometry Helper Functions ---\n\ndef get_bounding_box(polygon):\n    """Calculates the bounding box of a polygon."""\n    if not isinstance(polygon, np.ndarray):\n        polygon = np.array(polygon)\n    if polygon.shape[0] == 0: # Handle empty polygon\n        return np.array([float(\'inf\'), float(\'inf\')]), np.array([float(\'-inf\'), float(\'-inf\')])\n    min_coords = np.min(polygon, axis=0)\n    max_coords = np.max(polygon, axis=0)\n    return min_coords, max_coords\n\ndef rotate_polygon(polygon, angle, origin=(0, 0)):\n    """Rotates a polygon around a given origin."""\n    if not isinstance(polygon, np.ndarray):\n        polygon = np.array(polygon)\n    \n    translated_polygon = polygon - np.array(origin)\n    \n    c, s = np.cos(angle), np.sin(angle)\n    R = np.array([[c, -s], [s, c]])\n    \n    rotated_polygon = translated_polygon @ R\n    \n    return rotated_polygon + np.array(origin)\n\ndef translate_polygon(polygon, offset):\n    """Translates a polygon by an offset."""\n    if not isinstance(polygon, np.ndarray):\n        polygon = np.array(polygon)\n    return polygon + np.array(offset)\n\ndef calculate_polygon_area(polygon):\n    """Calculates the area of a polygon using the shoelace formula."""\n    if not isinstance(polygon, np.ndarray):\n        polygon = np.array(polygon)\n    x = polygon[:, 0]\n    y = polygon[:, 1]\n    return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))\n\n# --- Collision Detection Functions ---\n\ndef orientation(p, q, r):\n    """\n    Finds orientation of ordered triplet (p, q, r).\n    0 --> p, q and r are collinear\n    1 --> Clockwise\n    -1 --> Counterclockwise\n    """\n    val = (q[1] - p[1]) * (r[0] - q[0]) - \\\n          (q[0] - p[0]) * (r[1] - q[1])\n    if abs(val) < 1e-9: return 0  # collinear (with tolerance)\n    return 1 if val > 0 else -1 # clockwise or counterclockwise\n\ndef on_segment(p, q, r, epsilon=1e-9):\n    """Checks if point q lies on segment pr (with tolerance)."""\n    return (q[0] <= max(p[0], r[0]) + epsilon and q[0] >= min(p[0], r[0]) - epsilon and\n            q[1] <= max(p[1], r[1]) + epsilon and q[1] >= min(p[1], r[1]) - epsilon)\n\ndef segments_intersect(p1, q1, p2, q2):\n    """\n    Checks if line segment p1q1 intersects line segment p2q2.\n    """\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if o1 != 0 and o2 != 0 and o3 != 0 and o4 != 0 and o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases - collinear segments\n    if o1 == 0 and on_segment(p1, p2, q1): return True\n    if o2 == 0 and on_segment(p1, q2, q1): return True\n    if o3 == 0 and on_segment(p2, p1, q2): return True\n    if o4 == 0 and on_segment(p2, q1, q2): return True\n\n    return False # Doesn\'t fall in any of the above cases\n\ndef is_point_in_polygon(point, polygon):\n    """\n    Determines if a point is inside a polygon using the ray casting algorithm.\n    Assumes polygon is closed (implicit by loop). Handles points on boundaries.\n    """\n    n = len(polygon)\n    if n < 3: return False\n    inside = False\n    \n    p1 = polygon[0]\n    for i in range(n + 1):\n        p2 = polygon[i % n]\n        \n        # Check if point is on segment\n        if on_segment(p1, point, p2): return True\n\n        if ((p1[1] <= point[1] < p2[1]) or (p2[1] <= point[1] < p1[1])):\n            if (point[0] < (p2[0] - p1[0]) * (point[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]):\n                inside = not inside\n        p1 = p2\n    return inside\n\ndef do_polygons_overlap(poly1, poly2):\n    """\n    Checks if two polygons overlap using bounding box, vertex-in-polygon, and edge intersection.\n    """\n    min1, max1 = get_bounding_box(poly1)\n    min2, max2 = get_bounding_box(poly2)\n\n    # 1. Bounding box check\n    if max1[0] < min2[0] or min1[0] > max2[0] or \\\n       max1[1] < min2[1] or min1[1] > max2[1]:\n        return False # Bounding boxes don\'t overlap\n\n    # 2. Vertex in polygon check: if any vertex of A is inside B, or vice-versa\n    for p in poly1:\n        if is_point_in_polygon(p, poly2):\n            return True\n    for p in poly2:\n        if is_point_in_polygon(p, poly1):\n            return True\n\n    # 3. Edge intersection check\n    for i in range(len(poly1)):\n        p1 = poly1[i]\n        q1 = poly1[(i + 1) % len(poly1)]\n        for j in range(len(poly2)):\n            p2 = poly2[j]\n            q2 = poly2[(j + 1) % len(poly2)]\n            if segments_intersect(p1, q1, p2, q2):\n                return True\n\n    return False # No overlap found\n\ndef is_point_on_polygon_edge(point, polygon, epsilon=1e-9):\n    """Checks if a point lies on any edge of the polygon."""\n    n = len(polygon)\n    if n < 2: return False\n    for i in range(n):\n        p1 = polygon[i]\n        p2 = polygon[(i + 1) % n]\n        if on_segment(p1, point, p2): # Reusing on_segment with point as middle\n            return True\n    return False\n\ndef is_polygon_within_stock(piece_poly, stock_poly):\n    """\n    Checks if a piece polygon is entirely within the stock polygon.\n    1. Bounding box check.\n    2. All vertices of piece must be inside or on the boundary of stock.\n    3. Midpoints of piece edges must be inside the stock (to catch strict crossings).\n    """\n    min_piece, max_piece = get_bounding_box(piece_poly)\n    min_stock, max_stock = get_bounding_box(stock_poly)\n\n    # 1. Bounding box check - quick exit if piece bbox is outside stock bbox\n    if min_piece[0] < min_stock[0] - 1e-9 or max_piece[0] > max_stock[0] + 1e-9 or \\\n       min_piece[1] < min_stock[1] - 1e-9 or max_piece[1] > max_stock[1] + 1e-9:\n        return False\n\n    # 2. All vertices of piece must be inside stock (or on its boundary)\n    for vertex in piece_poly:\n        if not is_point_in_polygon(vertex, stock_poly):\n            return False\n\n    # 3. Midpoints of piece edges must be inside stock (to catch edges crossing boundaries)\n    # This is a heuristic to prevent edges from strictly crossing the stock boundary.\n    for i in range(len(piece_poly)):\n        p1 = piece_poly[i]\n        q1 = piece_poly[(i + 1) % len(piece_poly)]\n        mid_point_of_piece_edge = (p1 + q1) / 2.0\n        if not is_point_in_polygon(mid_point_of_piece_edge, stock_poly):\n            return False\n            \n    return True\n\n# --- Packing Algorithm Classes and Main Function ---\n\nclass PackingConfig:\n    def __init__(self, num_rotation_angles, grid_step_size_factor, max_translation_points):\n        self.num_rotation_angles = num_rotation_angles\n        self.grid_step_size_factor = grid_step_size_factor # Relative to stock width/height for step size\n        self.max_translation_points = max_translation_points # Max points to sample for translation\n\nTHOROUGH_CONFIG = PackingConfig(\n    num_rotation_angles=24,  # 15 degree steps\n    grid_step_size_factor=0.01,\n    max_translation_points=1000\n)\n\nFAST_CONFIG = PackingConfig(\n    num_rotation_angles=8,   # 45 degree steps\n    grid_step_size_factor=0.03,\n    max_translation_points=400\n)\n\nVERY_FAST_CONFIG = PackingConfig(\n    num_rotation_angles=4,   # 90 degree steps\n    grid_step_size_factor=0.05,\n    max_translation_points=100\n)\n\nULTRA_FAST_CONFIG = PackingConfig(\n    num_rotation_angles=2,   # 180 degree steps (0 and PI)\n    grid_step_size_factor=0.1,\n    max_translation_points=50\n)\n\ndef get_adaptive_config(num_pieces):\n    if num_pieces < 20:\n        return THOROUGH_CONFIG\n    elif num_pieces < 200:\n        return FAST_CONFIG\n    elif num_pieces < 1000:\n        return VERY_FAST_CONFIG\n    else: # 1000+ pieces\n        return ULTRA_FAST_CONFIG\n\ndef solve_polygon_cutting(stock_polygon, pieces):\n    stock_polygon_np = np.array(stock_polygon)\n    \n    processed_pieces = []\n    for i, piece_verts in enumerate(pieces):\n        piece_verts_np = np.array(piece_verts)\n        if len(piece_verts_np) < 3:\n            # Skip invalid polygons (less than 3 vertices)\n            continue\n        min_p, max_p = get_bounding_box(piece_verts_np)\n        # Centroid is used for initial rotation origin, then transformed by position\n        centroid = np.mean(piece_verts_np, axis=0)\n        area = calculate_polygon_area(piece_verts_np)\n        processed_pieces.append({\n            '}