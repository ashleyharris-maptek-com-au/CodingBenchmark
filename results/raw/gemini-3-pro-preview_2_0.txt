{'reasoning': "To solve the Chinese Postman Problem efficiently across scales ranging from 6 to 100,000 nodes, we employ a strategy that balances exactness with performance. \n\n1. **Graph Filtering**: We first run a BFS from the start node (0) to isolate the connected component. This handles disconnected graphs by ignoring unreachable edges, ensuring the solver focuses only on the traversable path.\n\n2. **Parity Analysis**: We identify nodes with odd degrees. A graph is Eulerian if all nodes have even degrees. If odd nodes exist, we must add virtual edges to pair them up, minimizing total weight.\n\n3. **Greedy Matching**: For small graphs, exact matching (Blossom) is ideal but complex. For 'Extreme' and 'Epic' scales (10k+ nodes), exact O(NÂ³) algorithms are too slow. We implement a 'Greedy Nearest Neighbor' heuristic. We iterate through unpaired odd nodes and run Dijkstra's algorithm to find the closest available odd node, pairing them immediately. This approach is highly efficient because the Dijkstra search terminates early (local search) rather than traversing the entire graph, making the matching phase roughly O(K * E_local) rather than O(K * E_total).\n\n4. **Eulerian Circuit**: Once the graph is balanced (all degrees even), we use an iterative version of Hierholzer's algorithm to find the circuit. To handle the large number of edges (up to 1M) efficiently in Python, we use a 'Lazy Removal' technique with a dictionary of edge counts and a stack-based adjacency list. This avoids O(degree) list removal operations, ensuring the traversal remains linear O(E) in time complexity.", 'python_code': "import heapq\nfrom collections import defaultdict, deque\n\ndef solve_cpp(num_nodes, edges):\n    # Handle trivial case\n    if not edges:\n        return [0]\n\n    # 1. Component Filtering (BFS from 0)\n    # Build a temp adjacency to check connectivity\n    adj_ref = defaultdict(list)\n    for u, v, w in edges:\n        adj_ref[u].append(v)\n        adj_ref[v].append(u)\n    \n    # Identify reachable nodes\n    reachable = set()\n    queue = deque([0])\n    reachable.add(0)\n    while queue:\n        u = queue.popleft()\n        for v in adj_ref[u]:\n            if v not in reachable:\n                reachable.add(v)\n                queue.append(v)\n\n    # 2. Build Weighted Graph & Calculate Degrees\n    # adj_weights: stores (neighbor, weight) for Dijkstra\n    # edge_counts: stores count of edges between u and v for Hierholzer\n    adj_weights = defaultdict(list)\n    edge_counts = defaultdict(lambda: defaultdict(int))\n    degree = defaultdict(int)\n    \n    valid_edges = 0\n    for u, v, w in edges:\n        if u in reachable and v in reachable:\n            adj_weights[u].append((v, w))\n            adj_weights[v].append((u, w))\n            \n            edge_counts[u][v] += 1\n            edge_counts[v][u] += 1\n            degree[u] += 1\n            degree[v] += 1\n            valid_edges += 1\n            \n    if valid_edges == 0:\n        return [0]\n\n    # 3. Matching Odd Degree Nodes (Greedy Heuristic)\n    odd_nodes = {n for n, d in degree.items() if d % 2 != 0}\n    \n    # Loop until all odd nodes are paired\n    while odd_nodes:\n        start_node = next(iter(odd_nodes))\n        odd_nodes.remove(start_node)\n        \n        # Run Dijkstra to find the nearest other odd node\n        pq = [(0, start_node)]\n        distances = {start_node: 0}\n        parents = {start_node: None}\n        target_node = None\n        \n        while pq:\n            d, u = heapq.heappop(pq)\n            \n            if d > distances.get(u, float('inf')):\n                continue\n            \n            # If we found another odd node, stop immediately\n            if u in odd_nodes:\n                target_node = u\n                break\n            \n            for v, w in adj_weights[u]:\n                new_dist = d + w\n                if new_dist < distances.get(v, float('inf')):\n                    distances[v] = new_dist\n                    parents[v] = u\n                    heapq.heappush(pq, (new_dist, v))\n        \n        # If no target found, node is isolated (shouldn't happen in connected component)\n        if target_node is None:\n            break\n            \n        # Pair found: remove target from set\n        odd_nodes.remove(target_node)\n        \n        # Backtrack path and add virtual edges to graph\n        curr = target_node\n        while curr != start_node:\n            prev = parents[curr]\n            # Add duplicated edge for Eulerian path\n            edge_counts[prev][curr] += 1\n            edge_counts[curr][prev] += 1\n            curr = prev\n\n    # 4. Hierholzer's Algorithm (Iterative)\n    # Prepare structures for fast O(1) edge selection\n    # Flatten edge_counts into an adjacency stack for simple popping\n    adj_stack = defaultdict(list)\n    # Track global available edge count to handle undirected removal lazily\n    edge_tracker = defaultdict(int)\n    \n    for u, neighbors in edge_counts.items():\n        for v, count in neighbors.items():\n            adj_stack[u].extend([v] * count)\n            if u <= v:\n                edge_tracker[(u, v)] = count\n\n    route = []\n    stack = [0]\n    \n    while stack:\n        u = stack[-1]\n        \n        # Try to find a valid edge\n        found_edge = False\n        while adj_stack[u]:\n            v = adj_stack[u].pop()\n            \n            # Normalize edge key\n            pair = (u, v) if u <= v else (v, u)\n            \n            # Check if this edge is still available (lazy removal)\n            if edge_tracker[pair] > 0:\n                edge_tracker[pair] -= 1\n                stack.append(v)\n                found_edge = True\n                break\n        \n        if not found_edge:\n            route.append(stack.pop())\n            \n    return route[::-1]"}