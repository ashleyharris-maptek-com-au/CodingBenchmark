{'reasoning': "The Travelling Salesman Problem (TSP) is NP-hard, meaning no efficient algorithm can find the optimal solution for large problem sizes. Therefore, an adaptive strategy is crucial, employing different algorithms based on the number of cities (N). My approach uses a hybrid strategy to balance solution quality and computational performance across the specified scales.\n\n1.  **For N <= 2000 (Trivial to Medium-Small scales):**\n    *   **Algorithm:** Nearest Neighbor (NN) heuristic followed by a 2-opt local search optimization.\n    *   **Reasoning:** The Nearest Neighbor heuristic quickly constructs an initial tour in O(N^2) time by always visiting the closest unvisited city. While NN often provides a suboptimal tour, it's a good starting point for local search. The 2-opt algorithm then refines this tour. A single pass of the optimized 2-opt algorithm (which calculates distance changes in O(1) time per swap) performs an O(N^2) search for improving swaps. For N up to 2000, N^2 (4 million operations) is computationally feasible within a few seconds. For very small N (e.g., <100 cities), multiple iterations of 2-opt are performed to achieve better quality, as the overhead is negligible.\n    *   **Complexity:** O(N^2) for Nearest Neighbor, O(N^2) per 2-opt pass. Total O(N^2) for this range.\n    *   **Quality:** Produces reasonably good routes for these sizes.\n\n2.  **For N > 2000 (Medium-Large to Epic scales):**\n    *   **Algorithm:** Space-Filling Curve (Z-order curve / Morton code) approximation.\n    *   **Reasoning:** For very large N (thousands to millions of cities), O(N^2) algorithms become too slow. An O(N log N) approach is required. Sorting cities based on their position along a space-filling curve like the Z-order curve is a common and highly effective approximation for TSP. It exploits spatial locality: points that are close in 2D space tend to have similar Z-order values, so visiting them in Z-order sequence creates a reasonably short tour. This approach is computationally efficient, dominated by the sorting step.\n    *   **Coordinates Scaling:** The `interleave_bits_scaled` function scales the given coordinates (which can be floats in the [0, 1000] range) to a higher integer resolution (e.g., 12 bits per coordinate). This preserves more precision during bit interleaving, leading to better Z-order separation for closely spaced cities and thus improved tour quality.\n    *   **Complexity:** O(N log N) due to sorting. This is highly efficient and can handle millions of cities within seconds.\n    *   **Quality:** Provides fast, good-enough approximations for massive problem instances where exact or advanced heuristics are too slow.\n\n**Adaptation Summary:**\n*   The `solve_tsp` function acts as a dispatcher, choosing between the O(N^2) Nearest Neighbor + 2-opt for smaller `N` (up to 2000) and the O(N log N) Z-order curve approximation for larger `N`.\n*   This adaptive logic ensures that computational resources are allocated appropriately: more intensive local search for smaller, quality-sensitive instances, and highly efficient approximations for large-scale performance-critical scenarios.\n*   Edge cases (empty or single-city lists) are handled explicitly.", 'python_code': 'import math\n\ndef euclidean_distance(p1, p2):\n    """Calculates the Euclidean distance between two points."""\n    return math.hypot(p1[0] - p2[0], p1[1] - p2[1])\n\ndef build_nearest_neighbor_tour(cities, start_node_idx):\n    """Constructs a tour using the Nearest Neighbor heuristic starting from start_node_idx."""\n    n = len(cities)\n    if n == 0:\n        return []\n    if n == 1:\n        return [0]\n\n    unvisited = set(range(n))\n    tour = [start_node_idx]\n    unvisited.remove(start_node_idx)\n    current_node = start_node_idx\n\n    while unvisited:\n        min_dist = float(\'inf\')\n        next_node = -1\n        for neighbor in unvisited:\n            dist = euclidean_distance(cities[current_node], cities[neighbor])\n            if dist < min_dist:\n                min_dist = dist\n                next_node = neighbor\n        tour.append(next_node)\n        unvisited.remove(next_node)\n        current_node = next_node\n    return tour\n\ndef two_opt_swap(tour, i, k):\n    """Performs a 2-opt swap on the tour segment between i and k."""\n    # Reverses the segment of the tour from index i+1 to k (inclusive)\n    return tour[:i+1] + tour[k:i:-1] + tour[k+1:]\n\ndef refine_with_2opt(cities, initial_tour, iterations=1):\n    """Refines a tour using the 2-opt local search heuristic (optimized O(N^2) per pass)."""\n    n = len(cities)\n    current_tour = list(initial_tour)\n\n    def calculate_total_distance(t):\n        dist = 0.0\n        for i in range(len(t)):\n            p1 = cities[t[i]]\n            p2 = cities[t[(i + 1) % n]] # Wrap around for the last segment\n            dist += euclidean_distance(p1, p2)\n        return dist\n\n    current_distance = calculate_total_distance(current_tour)\n\n    for _ in range(iterations):\n        improved_in_pass = False\n        # i iterates through the first endpoint of the first edge to be swapped\n        for i in range(n - 1): # i can be from 0 to n-2\n            # k iterates through the first endpoint of the second edge to be swapped\n            # k must be at least i+2 to ensure there\'s a segment to reverse (i.e., at least 2 edges apart)\n            for k in range(i + 2, n): # k can be from i+2 to n-1\n                # The edges being considered are (tour[i], tour[i+1]) and (tour[k], tour[(k+1)%n])\n                \n                p1_idx = current_tour[i]\n                p2_idx = current_tour[i + 1] # This is always (i+1)\n                p3_idx = current_tour[k]\n                p4_idx = current_tour[(k + 1) % n] # This properly handles wrap-around for the last segment\n\n                # Calculate old segment lengths\n                dist_old = (euclidean_distance(cities[p1_idx], cities[p2_idx]) +\n                            euclidean_distance(cities[p3_idx], cities[p4_idx]))\n\n                # Calculate new segment lengths (after hypothetical swap)\n                # This corresponds to: tour[i] -> tour[k] and tour[i+1] -> tour[k+1]\n                dist_new = (euclidean_distance(cities[p1_idx], cities[p3_idx]) +\n                            euclidean_distance(cities[p2_idx], cities[p4_idx]))\n\n                if dist_new < dist_old:\n                    # An improvement is found, apply the swap\n                    current_tour = two_opt_swap(current_tour, i, k)\n                    current_distance = current_distance - dist_old + dist_new\n                    improved_in_pass = True\n        if not improved_in_pass:\n            break\n    \n    return current_tour\n\ndef interleave_bits_scaled(x, y, max_val=1000.0, num_bits_per_coord=12):\n    """Interleaves bits of scaled x and y to create a Morton code (Z-order curve value)."""\n    # Scales coordinates from [0, max_val] to [0, 2^num_bits_per_coord - 1]\n    max_target_val = (1 << num_bits_per_coord) - 1\n    \n    # Scale and clamp coordinates to the target integer range\n    scaled_x = int(x / max_val * max_target_val)\n    scaled_y = int(y / max_val * max_target_val)\n    \n    scaled_x = max(0, min(scaled_x, max_target_val))\n    scaled_y = max(0, min(scaled_y, max_target_val))\n\n    z = 0\n    for i in range(num_bits_per_coord): # Process num_bits_per_coord bits for each coordinate\n        z |= ((scaled_x >> i) & 1) << (2 * i)     # Take i-th bit of x, place at 2*i\n        z |= ((scaled_y >> i) & 1) << (2 * i + 1) # Take i-th bit of y, place at 2*i+1\n    return z\n\ndef solve_tsp_z_order(cities):\n    """Solves TSP using Z-order curve approximation."""\n    if not cities:\n        return []\n    if len(cities) == 1:\n        return [0]\n\n    indexed_cities = []\n    max_coord_val = 1000.0 # Coordinates are in [0, 1000] as per problem statement\n    num_bits_for_zorder = 12 # 12 bits provide 4096 levels of precision for each coordinate\n\n    for i, (x, y) in enumerate(cities):\n        z_value = interleave_bits_scaled(x, y, max_coord_val, num_bits_for_zorder)\n        indexed_cities.append((z_value, i))\n\n    indexed_cities.sort() # Sorts based on the Z-order value\n    tour = [idx for _, idx in indexed_cities]\n\n    # Ensure the tour starts with city 0 by rotating the list\n    if tour and tour[0] != 0:\n        try:\n            start_idx = tour.index(0)\n            tour = tour[start_idx:] + tour[:start_idx]\n        except ValueError:\n            pass # Should not happen if 0 is a valid city index\n    return tour\n\ndef solve_tsp(cities):\n    """Main TSP solver function with adaptive logic for various scales."""\n    n = len(cities)\n\n    if n <= 1:\n        return [0] if n == 1 else []\n\n    # Threshold for switching between Nearest Neighbor + 2-opt and Z-order\n    # 2000 cities provides a good balance: NN+2-opt is feasible for quality,\n    # and Z-order takes over for larger N where O(N^2) becomes too slow.\n    TSP_2OPT_THRESHOLD = 2000 \n\n    if n <= TSP_2OPT_THRESHOLD:\n        # For smaller N, use Nearest Neighbor to build an initial tour, starting at city 0.\n        initial_tour = build_nearest_neighbor_tour(cities, start_node_idx=0)\n        \n        # For very small N, more 2-opt iterations can be afforded for better quality.\n        # For N closer to the threshold, a single pass is generally sufficient for performance.\n        num_2opt_iterations = 1\n        if n < 100:\n            num_2opt_iterations = 5 # More iterations for trivial cases\n\n        final_tour = refine_with_2opt(cities, initial_tour, iterations=num_2opt_iterations)\n        return final_tour\n    else:\n        # For larger N, use the fast Z-order curve approximation.\n        tour = solve_tsp_z_order(cities)\n        return tour\n'}