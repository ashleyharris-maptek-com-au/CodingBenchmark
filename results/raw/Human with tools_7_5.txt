{'reasoning': 'Using the trimesh library with its boolean operations: 1) Convert input meshes to trimesh.Trimesh objects. 2) Use trimesh.boolean.union() for CSG operation. 3) This leverages manifold3d or blender backend for robust booleans. 4) Return result as vertices and faces dict.', 'python_code': 'import numpy as np\n\ndef csg_union(mesh_a, mesh_b):\n    """\n    Compute CSG union of two meshes using trimesh library.\n    Returns dict with vertices and faces.\n    """\n    try:\n        import trimesh\n        \n        # Convert to trimesh objects\n        tm_a = trimesh.Trimesh(\n            vertices=np.array(mesh_a["vertices"]),\n            faces=np.array(mesh_a["faces"])\n        )\n        tm_b = trimesh.Trimesh(\n            vertices=np.array(mesh_b["vertices"]),\n            faces=np.array(mesh_b["faces"])\n        )\n        \n        # Perform boolean union\n        result = trimesh.boolean.union([tm_a, tm_b])\n        \n        # Convert back to dict format\n        return {\n            "vertices": result.vertices.tolist(),\n            "faces": result.faces.tolist()\n        }\n    except ImportError:\n        # Fallback: simple mesh concatenation (not true CSG)\n        # This just combines vertices and faces without boolean ops\n        verts_a = mesh_a["vertices"]\n        verts_b = mesh_b["vertices"]\n        faces_a = mesh_a["faces"]\n        faces_b = mesh_b["faces"]\n        \n        # Offset face indices for mesh_b\n        offset = len(verts_a)\n        faces_b_offset = [[f[0]+offset, f[1]+offset, f[2]+offset] for f in faces_b]\n        \n        return {\n            "vertices": verts_a + verts_b,\n            "faces": faces_a + faces_b_offset\n        }\n'}