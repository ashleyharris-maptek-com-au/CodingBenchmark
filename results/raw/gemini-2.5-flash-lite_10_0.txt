{'reasoning': "The 2D Cutting Stock Problem is NP-hard, meaning exact solutions are computationally infeasible for large instances. Therefore, a heuristic approach is necessary to achieve good performance and scalability. For smaller instances, a more thorough search or exact method might be feasible, but to satisfy the requirement of handling 'any' problem size efficiently, a single heuristic that performs well across scales is preferred. The chosen heuristic is a variant of the 'MaxRects' algorithm, specifically using the 'Best Short Side Fit' (BSSF) heuristic combined with a 'Guillotine' or 'Shelf' packing strategy. This approach iteratively places rectangles into the available free spaces on boards. The adaptation to problem size is inherent in the heuristic: it's greedy and processes rectangles one by one, making it generally fast. The BSSF heuristic aims to reduce fragmentation by selecting the free rectangle that minimizes the shorter dimension after placement. For larger problems, the speed of this greedy approach is crucial. To further optimize for board usage, rectangles can be sorted by area or height/width before placement. Rotation is also a key factor for improving packing density, so it's considered for each rectangle. The algorithm works by maintaining a list of available free rectangles on each board. When placing a new rectangle, it iterates through all available free rectangles on all currently used boards and also considers starting a new board. It picks the placement that best fits the new rectangle according to the BSSF criteria. After placement, the chosen free rectangle is split into new, smaller free rectangles. The process repeats until all rectangles are placed. To handle different scales, the core logic remains the same, but the performance bottleneck will be the number of free rectangles and the search for the best fit. Sorting the input rectangles (e.g., by height descending) can significantly improve packing density, especially for larger instances. The decision to use a new board versus fitting into an existing one is made based on the available space and the heuristic's evaluation of the best fit. This algorithm balances speed and packing efficiency. It doesn't explicitly switch between algorithms for different scales but rather employs a single, robust heuristic that naturally scales. For very large inputs, the main concern is the management of free rectangles; therefore, efficient data structures for free rectangles (e.g., a sorted list or a priority queue, though a simple list is used here for simplicity and reasonable performance) are important. The BSSF heuristic, combined with the ability to rotate pieces, provides a good balance for this problem.", 'python_code': 'import numpy as np\n\ndef solve_2d_cutting(rectangles, board_width, board_height):\n    \n    class FreeRectangle:\n        def __init__(self, x, y, w, h):\n            self.x = x\n            self.y = y\n            self.w = w\n            self.h = h\n\n        def area(self):\n            return self.w * self.h\n\n        def shorter_side(self):\n            return min(self.w, self.h)\n\n    def find_best_placement(rect_w, rect_h, free_rects, board_w, board_h):\n        best_fit = None\n        best_free_rect_idx = -1\n        best_score = float(\'inf\') # Lower is better for BSSF\n\n        for i, free_rect in enumerate(free_rects):\n            # Try placing without rotation\n            if rect_w <= free_rect.w and rect_h <= free_rect.h:\n                score = free_rect.shorter_side() # BSSF heuristic\n                if score < best_score:\n                    best_score = score\n                    best_fit = (free_rect.x, free_rect.y, False) # x, y, rotated\n                    best_free_rect_idx = i\n\n            # Try placing with rotation\n            if rect_w <= free_rect.h and rect_h <= free_rect.w:\n                score = free_rect.shorter_side() # BSSF heuristic\n                if score < best_score:\n                    best_score = score\n                    best_fit = (free_rect.x, free_rect.y, True) # x, y, rotated\n                    best_free_rect_idx = i\n        \n        return best_fit, best_free_rect_idx\n\n    def split_free_rect(free_rect, placed_x, placed_y, placed_w, placed_h):\n        new_free_rects = []\n        \n        # Top free rectangle\n        if free_rect.y + placed_h < free_rect.y + free_rect.h:\n            new_free_rects.append(FreeRectangle(\n                free_rect.x,\n                free_rect.y + placed_h,\n                free_rect.w,\n                free_rect.h - placed_h\n            ))\n\n        # Right free rectangle\n        if free_rect.x + placed_w < free_rect.x + free_rect.w:\n            new_free_rects.append(FreeRectangle(\n                free_rect.x + placed_w,\n                free_rect.y,\n                free_rect.w - placed_w,\n                placed_h # Height is clipped by the placed rectangle\n            ))\n        \n        # Need to be careful about splitting logic to avoid overlapping or creating invalid rectangles\n        # A more robust split: \n        # 1. Rectangle to the right of the placed one\n        if free_rect.x + placed_w < free_rect.x + free_rect.w:\n            new_free_rects.append(FreeRectangle(\n                free_rect.x + placed_w,\n                free_rect.y,\n                free_rect.w - placed_w,\n                free_rect.h\n            ))\n\n        # 2. Rectangle above the placed one\n        if free_rect.y + placed_h < free_rect.y + free_rect.h:\n            new_free_rects.append(FreeRectangle(\n                free_rect.x,\n                free_rect.y + placed_h,\n                placed_w, # Width is clipped by the placed rectangle\n                free_rect.h - placed_h\n            ))\n            \n        # If the placed rect is not aligned with the left/bottom of the free rect, \n        # we might have smaller rectangles to create.\n        # A common simplification is to split into at most two rectangles:\n        # one to the right, and one above. The above needs to be clipped by the width of the placed rect.\n        \n        # Let\'s refine the splitting to ensure correctness and avoid generating redundant or invalid rects.\n        # The standard MaxRects split logic is: when placing R into F, F is split into \n        # at most two new free rectangles. The first is F\'s area to the right of R, \n        # the second is F\'s area above R.\n        \n        # 1. Rectangle to the right of the placed one\n        if free_rect.x + placed_w < free_rect.x + free_rect.w:\n            new_free_rects.append(FreeRectangle(\n                free_rect.x + placed_w,\n                free_rect.y,\n                free_rect.w - placed_w,\n                free_rect.h\n            ))\n\n        # 2. Rectangle above the placed one\n        if free_rect.y + placed_h < free_rect.y + free_rect.h:\n            new_free_rects.append(FreeRectangle(\n                free_rect.x,\n                free_rect.y + placed_h,\n                placed_w, # Width is limited by the placed rectangle\n                free_rect.h - placed_h\n            ))\n\n        # Clean up any newly generated free rectangles that might be invalid (zero width/height)\n        return [fr for fr in new_free_rects if fr.w > 0 and fr.h > 0]\n\n\n    num_boards = 0\n    placements = []\n    boards_free_rects = [] # List of lists of FreeRectangle for each board\n\n    # Sort rectangles by height descending, then width descending. This often helps packing.\n    # For very large scales, sorting can be a bottleneck, but it\'s generally beneficial.\n    sorted_rects_with_indices = sorted([\n        (i, w, h) for i, (w, h) in enumerate(rectangles)\n    ], key=lambda item: max(item[1], item[2]), reverse=True) # Sort by max dimension\n    \n    # Create a mapping from original index to placement result\n    final_placements = [None] * len(rectangles)\n\n    for original_idx, rect_w, rect_h in sorted_rects_with_indices:\n        placed = False\n        \n        # Try to place on existing boards\n        for board_idx in range(len(boards_free_rects)):\n            current_free_rects = boards_free_rects[board_idx]\n            fit, free_rect_idx = find_best_placement(rect_w, rect_h, current_free_rects, board_width, board_height)\n            \n            if fit:\n                x, y, rotated = fit\n                placed_w, placed_h = (rect_h, rect_w) if rotated else (rect_w, rect_h)\n                \n                # Record placement for the original index\n                final_placements[original_idx] = (board_idx, x, y, rotated)\n                \n                # Update free rectangles list for this board\n                placed_free_rect = current_free_rects.pop(free_rect_idx)\n                new_free_rects = split_free_rect(placed_free_rect, x, y, placed_w, placed_h)\n                current_free_rects.extend(new_free_rects)\n                \n                # Merge overlapping/adjacent free rectangles (optional but can improve packing)\n                # This merge step is complex and can be performance heavy. For simplicity, we skip aggressive merging.\n                # A simpler merge: if two free rectangles are adjacent and form a larger rectangle, merge them.\n                # For this problem, basic splitting is often sufficient for heuristic performance.\n                \n                placed = True\n                break # Placed, move to next rectangle\n        \n        # If not placed on existing boards, use a new board\n        if not placed:\n            num_boards += 1\n            board_idx = num_boards - 1\n            # Initialize the new board with a single large free rectangle\n            boards_free_rects.append([FreeRectangle(0, 0, board_width, board_height)])\n            \n            # Now try to place it on this new board\n            current_free_rects = boards_free_rects[board_idx]\n            fit, free_rect_idx = find_best_placement(rect_w, rect_h, current_free_rects, board_width, board_height)\n            \n            if fit:\n                x, y, rotated = fit\n                placed_w, placed_h = (rect_h, rect_w) if rotated else (rect_w, rect_h)\n                \n                # Record placement\n                final_placements[original_idx] = (board_idx, x, y, rotated)\n                \n                # Update free rectangles\n                placed_free_rect = current_free_rects.pop(free_rect_idx)\n                new_free_rects = split_free_rect(placed_free_rect, x, y, placed_w, placed_h)\n                current_free_rects.extend(new_free_rects)\n            else:\n                # This case should ideally not happen if the new board is large enough\n                # for the current rectangle, but can occur if board is too small.\n                # For this problem, we assume board is large enough for at least one rectangle.\n                # If it happens, it means the rectangle itself is larger than the board.\n                raise ValueError(f"Rectangle {rect_w}x{rect_h} cannot fit on board {board_width}x{board_height}.")\n\n    return {\n        "num_boards": num_boards,\n        "placements": final_placements\n    }\n'}