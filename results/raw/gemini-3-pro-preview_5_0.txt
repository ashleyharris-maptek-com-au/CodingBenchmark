{'reasoning': "The problem requires solving the Hamiltonian Path problem on grids up to 50x50, which is NP-complete but tractable on grids using heuristics. \n\nStrategy:\n1. **Representation**: Flatten the 2D grid into a 1D graph structure for performance.\n2. **Pruning (Parity)**: Use checkerboard coloring. A path must respect bipartite matching constraints (Black/White counts). If counts don't align with path/cycle requirements, return immediately.\n3. **Pruning (Connectivity)**: Perform an initial BFS to ensure the valid cells form a connected component. Disconnected components make a full path impossible.\n4. **Algorithm**: Recursive Backtracking with Warnsdorff's Rule.\n   - **Heuristic**: Always explore neighbors with the fewest available moves (lowest degree) first. This minimizes the chance of creating isolated islands or dead ends.\n   - **Dynamic Degree Updates**: Maintain a live count of unvisited neighbors for every cell. This allows O(1) heuristic lookup.\n   - **Dead-End Lookahead**: When visiting a node reduces a neighbor's degree to 0, that neighbor becomes a 'dead end'. If we are not at the last step of the path, creating a dead end makes the solution impossible. We prune these branches immediately.\n5. **Scalability**: The combination of degree-based sorting and dead-end pruning allows the solver to handle 50x50 grids (2500 nodes) efficiently, often without deep backtracking.", 'python_code': "import sys\n\ndef find_hamiltonian_path(width, height, obstacles, require_cycle):\n    # Increase recursion limit for large grids (50x50 = 2500 steps)\n    sys.setrecursionlimit(max(2000, width * height + 500))\n    \n    obs_set = set(obstacles)\n    total_cells = width * height\n    valid_cells = total_cells - len(obs_set)\n    \n    if valid_cells == 0:\n        return []\n\n    # Check start position validity\n    if (0, 0) in obs_set:\n        return []\n\n    # 1. Parity Check (Checkerboard coloring)\n    # (0,0) is Black (even sum). \n    black_count = 0\n    white_count = 0\n    \n    # Precompute grid structure\n    # Map (x,y) -> int index\n    # Indices: 0 to width*height - 1\n    adj = [[] for _ in range(total_cells)]\n    \n    # Track valid cells to verify connectivity\n    valid_indices = []\n    \n    for y in range(height):\n        for x in range(width):\n            if (x, y) not in obs_set:\n                idx = y * width + x\n                valid_indices.append(idx)\n                if (x + y) % 2 == 0:\n                    black_count += 1\n                else:\n                    white_count += 1\n                \n                # Build adjacency\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < width and 0 <= ny < height:\n                        if (nx, ny) not in obs_set:\n                            adj[idx].append(ny * width + nx)\n\n    # Parity logic\n    if require_cycle:\n        # Cycle on bipartite graph requires equal partition sizes\n        if black_count != white_count:\n            return []\n    else:\n        # Path starting at Black (0,0):\n        # If length is even, Black == White\n        # If length is odd, Black == White + 1\n        if valid_cells % 2 == 0:\n            if black_count != white_count:\n                return []\n        else:\n            if black_count != white_count + 1:\n                return []\n\n    # 2. Connectivity Check\n    # BFS from (0,0) to ensure all valid cells are reachable\n    start_node = 0 # (0,0)\n    q = [start_node]\n    visited_bfs = {start_node}\n    count_bfs = 0\n    while q:\n        u = q.pop(0)\n        count_bfs += 1\n        for v in adj[u]:\n            if v not in visited_bfs:\n                visited_bfs.add(v)\n                q.append(v)\n    \n    if count_bfs != valid_cells:\n        return []\n\n    # 3. Solver Initialization\n    # State arrays\n    path = [start_node]\n    visited = [False] * total_cells\n    visited[start_node] = True\n    \n    # Degrees: count of unvisited valid neighbors\n    degrees = [0] * total_cells\n    for i in valid_indices:\n        degrees[i] = len(adj[i])\n    \n    # Update neighbors of start node (since start is visited)\n    for v in adj[start_node]:\n        degrees[v] -= 1\n\n    # 4. Recursive Backtracking\n    def solve():\n        # Base Case\n        if len(path) == valid_cells:\n            if require_cycle:\n                # Must be adjacent to start_node\n                # Since graph is undirected, check if start is in adj of last\n                if start_node in adj[path[-1]]:\n                    return True\n                return False\n            return True\n            \n        u = path[-1]\n        \n        # Get valid neighbors\n        # Optimization: Filter unvisited and Sort by degree (Warnsdorff's rule)\n        candidates = []\n        for v in adj[u]:\n            if not visited[v]:\n                candidates.append(v)\n        \n        # Sort candidates by number of their unvisited neighbors (degree)\n        # Ascending: prefer constrained nodes first to avoid dead ends\n        candidates.sort(key=lambda x: degrees[x])\n        \n        for v in candidates:\n            # Forward track\n            visited[v] = True\n            path.append(v)\n            \n            # Update degrees of neighbors of v\n            # We collect modified indices to rollback later\n            modified = []\n            zeros = 0\n            possible = True\n            \n            for w in adj[v]:\n                if not visited[w]:\n                    degrees[w] -= 1\n                    modified.append(w)\n                    if degrees[w] == 0:\n                        zeros += 1\n            \n            # Dead-end pruning\n            # If we created a dead end (degree 0) and we are not at the last step,\n            # the path is invalid.\n            # Logic: If degrees[w] == 0, w must be the immediate next step and the final step.\n            # If we have > 1 zeros, impossible.\n            # If we have 1 zero, but we need > 1 steps to finish, impossible.\n            if zeros > 0:\n                if zeros > 1:\n                    possible = False\n                elif (valid_cells - len(path)) > 1:\n                    possible = False\n            \n            if possible:\n                if solve():\n                    return True\n            \n            # Backtrack\n            # Restore degrees\n            for w in modified:\n                degrees[w] += 1\n            \n            path.pop()\n            visited[v] = False\n            \n        return False\n\n    if solve():\n        # Convert indices back to coordinates\n        return [(idx % width, idx // width) for idx in path]\n    else:\n        return []"}