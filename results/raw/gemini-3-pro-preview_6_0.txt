{'reasoning': "I implemented a scale-adaptive solver. For orbital mechanics, I modeled the cost metric using a bi-impulsive approximation: a Hohmann transfer for altitude changes combined with a plane change maneuver at the relative node (approximated at the largest semi-major axis to minimize delta-v). This avoids the complexity of phasing (Time-Dependent TSP) while providing a physically grounded 'static' cost. For the TSP algorithm, I used a conditional approach: for small inputs (N <= 8), a brute-force permutation search guarantees optimality. For larger inputs (N > 8), I implemented a Nearest Neighbor construction followed by a 2-Opt local search optimization. This ensures the solution scales efficiently to 100 stations, running in milliseconds/seconds while providing high-quality paths.", 'python_code': 'import math\nimport itertools\n\ndef solve_orbital_tsp(start_orbit, station_orbits, mu):\n    """\n    Solves the Orbital TSP by calculating heuristic Delta-V costs between orbits\n    and applying either Brute Force (small N) or Nearest Neighbor + 2-Opt (large N).\n    """\n\n    # --- 1. Vector & Physics Utilities ---\n    \n    def vec_norm(v):\n        return math.sqrt(sum(x*x for x in v))\n    \n    def vec_dot(v1, v2):\n        return sum(x*y for x, y in zip(v1, v2))\n\n    def vec_cross(a, b):\n        return [\n            a[1]*b[2] - a[2]*b[1],\n            a[2]*b[0] - a[0]*b[2],\n            a[0]*b[1] - a[1]*b[0]\n        ]\n\n    def get_orbital_elements(state_vec):\n        # Extract state\n        r_vec = state_vec[:3]\n        v_vec = state_vec[3:]\n        \n        r = vec_norm(r_vec)\n        v = vec_norm(v_vec)\n        \n        # Angular momentum\n        h_vec = vec_cross(r_vec, v_vec)\n        h = vec_norm(h_vec)\n        \n        # Specific Energy: E = v^2/2 - mu/r\n        # Semi-major axis: a = -mu / 2E\n        E = (v**2)/2 - mu/r\n        \n        # Handle circular/parabolic cases roughly (avoid div by zero)\n        if abs(E) < 1e-10: \n            a = float(\'inf\') # Parabolic\n        else:\n            a = -mu / (2 * E)\n            \n        return {\'a\': a, \'h_vec\': h_vec, \'h_mag\': h}\n\n    def calculate_transfer_dv(orb1, orb2):\n        """\n        Estimates dV required to transfer between two orbits.\n        Cost = Plane Change + Shape Change (Hohmann-like approximation).\n        """\n        # 1. Shape Change (Hohmann approx)\n        # Delta-V to go from circular orbit r1 to r2\n        r1 = orb1[\'a\']\n        r2 = orb2[\'a\']\n        \n        # Velocities in circular orbits\n        vc1 = math.sqrt(mu / r1)\n        vc2 = math.sqrt(mu / r2)\n        \n        # Hohmann transfer velocities\n        # Transfer orbit semi-major axis\n        at = (r1 + r2) / 2\n        \n        # Velocity at periapsis/apoapsis of transfer orbit\n        vt1 = math.sqrt(mu * (2/r1 - 1/at))\n        vt2 = math.sqrt(mu * (2/r2 - 1/at))\n        \n        dv_shape = abs(vt1 - vc1) + abs(vt2 - vc2)\n        \n        # 2. Plane Change\n        # Angle between momentum vectors\n        dot = vec_dot(orb1[\'h_vec\'], orb2[\'h_vec\'])\n        denom = orb1[\'h_mag\'] * orb2[\'h_mag\']\n        \n        # Safety clamp\n        cos_inc = max(-1.0, min(1.0, dot / denom))\n        inc_change = math.acos(cos_inc)\n        \n        if inc_change < 1e-9:\n            dv_plane = 0.0\n        else:\n            # Optimal plane change is done at the lowest velocity point.\n            # In a Hohmann transfer r1->r2, this is at max(r1, r2).\n            # We approximate the node velocity as the circular velocity of the larger orbit.\n            r_max = max(r1, r2)\n            v_node = math.sqrt(mu / r_max)\n            dv_plane = 2 * v_node * math.sin(inc_change / 2)\n            \n        # We sum them (pessimistic/robust approximation). \n        # Combined maneuvers are more efficient but complex to estimate without phasing.\n        return dv_shape + dv_plane\n\n    # --- 2. Precomputation ---\n    \n    start_elems = get_orbital_elements(start_orbit)\n    station_elems = [get_orbital_elements(s) for s in station_orbits]\n    num_stations = len(station_orbits)\n    indices = list(range(num_stations))\n\n    # Precompute Cost Matrix\n    # Distance from Start to each station\n    dist_start = [calculate_transfer_dv(start_elems, s) for s in station_elems]\n    \n    # Distance between stations (symmetric)\n    dist_matrix = [[0.0] * num_stations for _ in range(num_stations)]\n    for i in range(num_stations):\n        for j in range(i + 1, num_stations):\n            cost = calculate_transfer_dv(station_elems[i], station_elems[j])\n            dist_matrix[i][j] = cost\n            dist_matrix[j][i] = cost\n\n    # --- 3. Solver ---\n\n    best_order = []\n    min_total_dv = float(\'inf\')\n    \n    # Heuristic limit for Brute Force (8! is small, 9-10! gets slow)\n    BRUTE_FORCE_LIMIT = 8 \n\n    if num_stations <= BRUTE_FORCE_LIMIT:\n        # Strategy: Brute Force Permutations\n        # Trivial scale. Guaranteed optimal for the given metric.\n        for perm in itertools.permutations(indices):\n            # Calculate cost\n            # Start -> First\n            current_dv = dist_start[perm[0]]\n            \n            # Station -> Station\n            for k in range(num_stations - 1):\n                u, v = perm[k], perm[k+1]\n                current_dv += dist_matrix[u][v]\n            \n            if current_dv < min_total_dv:\n                min_total_dv = current_dv\n                best_order = list(perm)\n                \n    else:\n        # Strategy: Greedy Nearest Neighbor + 2-Opt Local Search\n        # Scalable for Large/Extreme inputs.\n        \n        # A. Greedy Construction\n        unvisited = set(indices)\n        \n        # Pick closest to start\n        curr_node = -1\n        best_start_d = float(\'inf\')\n        for i in unvisited:\n            if dist_start[i] < best_start_d:\n                best_start_d = dist_start[i]\n                curr_node = i\n                \n        greedy_path = [curr_node]\n        unvisited.remove(curr_node)\n        greedy_cost = best_start_d\n        \n        while unvisited:\n            next_node = -1\n            min_d = float(\'inf\')\n            for cand in unvisited:\n                d = dist_matrix[curr_node][cand]\n                if d < min_d:\n                    min_d = d\n                    next_node = cand\n            \n            greedy_path.append(next_node)\n            greedy_cost += min_d\n            unvisited.remove(next_node)\n            curr_node = next_node\n            \n        best_order = greedy_path\n        min_total_dv = greedy_cost\n        \n        # B. 2-Opt Optimization\n        # Iteratively attempt to swap edges to reduce length\n        improved = True\n        iterations = 0\n        max_iter = 2000 # Safety break\n        \n        while improved and iterations < max_iter:\n            improved = False\n            iterations += 1\n            \n            # We look at swapping segment path[i..j]\n            # Indices refer to the position in the path list, not station ID\n            # Valid range for i: 0 to N-2\n            # Valid range for j: i+1 to N-1\n            \n            for i in range(num_stations - 1):\n                for j in range(i + 1, num_stations):\n                    # Nodes at boundaries\n                    # A = path[i], B = path[j]\n                    # Pre-A is path[i-1] or Start\n                    # Post-B is path[j+1] or End (None)\n                    \n                    node_a = best_order[i]\n                    node_b = best_order[j]\n                    \n                    # Cost of entering A\n                    if i == 0:\n                        cost_pre_old = dist_start[node_a]\n                        cost_pre_new = dist_start[node_b] # If swapped, we enter B from start\n                    else:\n                        node_pre = best_order[i-1]\n                        cost_pre_old = dist_matrix[node_pre][node_a]\n                        cost_pre_new = dist_matrix[node_pre][node_b]\n                        \n                    # Cost of leaving B\n                    if j == num_stations - 1:\n                        cost_post_old = 0\n                        cost_post_new = 0\n                    else:\n                        node_post = best_order[j+1]\n                        cost_post_old = dist_matrix[node_b][node_post]\n                        cost_post_new = dist_matrix[node_a][node_post] # If swapped, we leave A to post\n                        \n                    # Calculate change\n                    # The internal path cost i..j is unchanged because distance matrix is symmetric\n                    # and we just reverse the direction.\n                    \n                    diff = (cost_pre_new + cost_post_new) - (cost_pre_old + cost_post_old)\n                    \n                    if diff < -1e-6:\n                        # Apply swap: reverse segment [i, j]\n                        best_order[i:j+1] = best_order[i:j+1][::-1]\n                        min_total_dv += diff\n                        improved = True\n                        break # Restart loop from improved state\n                if improved: break\n\n    # --- 4. Result ---\n    \n    reasoning_text = (\n        f"Used {\'Brute Force\' if num_stations <= BRUTE_FORCE_LIMIT else \'Nearest Neighbor + 2-Opt\'} "\n        f"for {num_stations} stations. Metric combines Plane Change and Hohmann Transfer Delta-V."\n    )\n    \n    return {\n        "visit_order": best_order,\n        "total_delta_v": min_total_dv,\n        "reasoning": reasoning_text\n    }\n'}