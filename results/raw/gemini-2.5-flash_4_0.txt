{'reasoning': "The core strategy for packing tetrahedrons into polyhedra across various scales is an adaptive, grid-based sequential placement algorithm. This approach balances packing density, performance, and scalability by dynamically adjusting its parameters based on the estimated volume of the container.\n\n1.  **Container Volume Estimation and Strategy Adaptation**: Initially, the algorithm calculates the Axis-Aligned Bounding Box (AABB) of the input `container_vertices` and its volume. This AABB volume serves as a proxy for the container's scale. Based on this volume, the algorithm switches between three main strategies:\n    *   **Small Containers (e.g., < (15 * edge_length)^3)**: For smaller volumes, the algorithm employs a finer `placement_step_size` (half the tetrahedron's edge length) and considers more `rotation_options` (up to 6 distinct 90-degree rotations around major axes). This aims for a denser packing by exploring more potential orientations and packing locations.\n    *   **Medium Containers (e.g., < (60 * edge_length)^3)**: For medium volumes, a standard `placement_step_size` (equal to the edge length) is used, and a reduced set of `rotation_options` (e.g., default and 90-degree around X-axis) is considered. This provides a balance between density and performance.\n    *   **Large/Very Large Containers (e.g., >= (60 * edge_length)^3)**: For massive volumes, the algorithm prioritizes speed. It uses a coarser `placement_step_size` (1.2 times the edge length) and typically only one `rotation_option` (the default orientation). This strategy focuses on rapidly filling the bulk of the container, accepting a potentially lower packing density at the boundaries or for specific complex shapes.\n\n2.  **Tetrahedron Geometry**: Regular tetrahedron vertices are pre-calculated for a canonical, origin-centered orientation based on the given `edge_length`. Rotations are applied using Euler angles (ZXY order) to these canonical vertices, followed by translation to the `center` of the tetrahedron. This ensures correct geometry and orientation for each placed tetrahedron.\n\n3.  **Containment Check (Simplification)**: A critical simplification made due to the 'standard library only' constraint is how `is_tetra_in_container` is handled. For a general convex polyhedron, this would ideally involve checking each tetrahedron vertex against the planes of the container's faces (which would first require computing the convex hull faces from the input vertices). However, without a dedicated convex hull library (like SciPy), this is computationally intensive and complex to implement from scratch. Therefore, the algorithm approximates the container as its Axis-Aligned Bounding Box (AABB). A tetrahedron is considered 'inside' if all its vertices are within this container AABB. This ensures scalability but means that if the actual container is not an AABB, tetrahedrons might be placed within the container's AABB but outside its true geometric boundary. This design choice prioritizes performance and standard library adherence over perfect geometric accuracy for complex convex polyhedra.\n\n4.  **Collision Detection**: To maximize performance for overlapping checks, particularly with a large number of tetrahedrons:\n    *   **AABB Overlap**: The primary collision detection between two tetrahedrons relies on checking for overlap between their respective Axis-Aligned Bounding Boxes (AABBs). This is a fast, conservative test. If AABBs don't overlap, the tetrahedrons don't overlap. If they do, for the purpose of this problem's performance constraints, they are conservatively considered to overlap. A precise Separating Axis Theorem (SAT) or GJK algorithm would be more accurate but significantly slower for many checks.\n    *   **Spatial Hashing (Grid)**: To further optimize collision checks, a 3D spatial grid (implemented as a dictionary mapping grid cell coordinates to lists of contained tetrahedron vertices) is used. When a new tetrahedron is a candidate for placement, its AABB is used to identify which grid cells it potentially overlaps. Collision checks are then only performed against previously placed tetrahedrons that reside within these identified cells, drastically reducing the number of pairwise checks compared to an N^2 approach.\n\n5.  **Placement Heuristic**: Tetrahedrons are placed sequentially using a simple 'sweep' approach. Candidate centers are generated by iterating through the container's AABB using the `placement_step_size`. For each candidate center, the available `rotation_options` are tried. The first valid placement (inside container AABB and no overlap with existing tetrahedrons) is accepted. This greedy, first-fit approach is efficient for large-scale problems, prioritizing speed over finding the absolute optimal local packing arrangement that might require more complex search or optimization techniques.", 'python_code': 'import math\n\n# --- Vector and Rotation Utilities ---\ndef vec_add(v1, v2): \n    return (v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2])\ndef vec_sub(v1, v2): \n    return (v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2])\ndef vec_mul_scalar(v, s): \n    return (v[0] * s, v[1] * s, v[2] * s)\ndef vec_dot(v1, v2): \n    return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]\ndef vec_len(v): \n    return math.sqrt(vec_dot(v, v))\n\n# Apply Euler rotations (ZXY order: Z-axis first, then X, then Y)\ndef rotate_point(p, rotation):\n    rx, ry, rz = rotation\n    \n    # Z-rotation (yaw)\n    p_z_x = p[0] * math.cos(rz) - p[1] * math.sin(rz)\n    p_z_y = p[0] * math.sin(rz) + p[1] * math.cos(rz)\n    p_z_z = p[2]\n    \n    # X-rotation (roll)\n    p_zx_x = p_z_x\n    p_zx_y = p_z_y * math.cos(rx) - p_z_z * math.sin(rx)\n    p_zx_z = p_z_y * math.sin(rx) + p_z_z * math.cos(rx)\n    \n    # Y-rotation (pitch)\n    p_zxy_x = p_zx_x * math.cos(ry) + p_zx_z * math.sin(ry)\n    p_zxy_y = p_zx_y\n    p_zxy_z = -p_zx_x * math.sin(ry) + p_zx_z * math.cos(ry)\n    \n    return (p_zxy_x, p_zxy_y, p_zxy_z)\n\n# --- Tetrahedron Geometry ---\n# Canonical vertices for a regular tetrahedron of edge_length e, centered at origin\ndef _get_canonical_tetra_vertices(edge_length):\n    # For a tetrahedron with edge length \'e\' centered at origin, the vertices can be simplified as\n    # (s,s,s), (s,-s,-s), (-s,s,-s), (-s,-s,s) where the actual edge length \'e\' = s * sqrt(8).\n    # Solving for s: s = e / sqrt(8).\n    s_val = edge_length / math.sqrt(8)\n    return [\n        (s_val, s_val, s_val),\n        (s_val, -s_val, -s_val),\n        (-s_val, s_val, -s_val),\n        (-s_val, -s_val, s_val)\n    ]\n\n# Get actual vertices of a tetrahedron given its center, rotation, and edge_length\ndef get_tetra_vertices(center, rotation, edge_length, canonical_verts=None):\n    if canonical_verts is None:\n        canonical_verts = _get_canonical_tetra_vertices(edge_length)\n    \n    rotated_verts = [rotate_point(v, rotation) for v in canonical_verts]\n    return [vec_add(center, rv) for rv in rotated_verts]\n\n# Get the AABB (Axis-Aligned Bounding Box) for a set of vertices\ndef get_aabb(vertices):\n    min_x = min(v[0] for v in vertices)\n    min_y = min(v[1] for v in vertices)\n    min_z = min(v[2] for v in vertices)\n    max_x = max(v[0] for v in vertices)\n    max_y = max(v[1] for v in vertices)\n    max_z = max(v[2] for v in vertices)\n    return (min_x, min_y, min_z, max_x, max_y, max_z)\n\n# --- Collision and Containment Checks ---\n# Check if a point is inside the container\'s AABB (with epsilon for float comparison)\ndef _is_point_inside_aabb(point, container_min_xyz, container_max_xyz, epsilon=1e-9):\n    return (container_min_xyz[0] <= point[0] + epsilon and point[0] - epsilon <= container_max_xyz[0] and\n            container_min_xyz[1] <= point[1] + epsilon and point[1] - epsilon <= container_max_xyz[1] and\n            container_min_xyz[2] <= point[2] + epsilon and point[2] - epsilon <= container_max_xyz[2])\n\n# Check if a tetrahedron is entirely inside the container\'s AABB\ndef is_tetra_in_container_aabb(tetra_vertices, container_min_xyz, container_max_xyz):\n    for v in tetra_vertices:\n        if not _is_point_inside_aabb(v, container_min_xyz, container_max_xyz):\n            return False\n    return True\n\n# Check if two AABBs overlap\ndef is_aabb_overlap(aabb1, aabb2):\n    min1_x, min1_y, min1_z, max1_x, max1_y, max1_z = aabb1\n    min2_x, min2_y, min2_z, max2_x, max2_y, max2_z = abb2\n    \n    return (max1_x > min2_x and min1_x < max2_x and\n            max1_y > min2_y and min1_y < max2_y and\n            max1_z > min2_z and min1_z < max2_z)\n\n# Simplified tetrahedron overlap check using AABB overlap.\n# This is a critical simplification for performance on large scales, \n# but might lead to less dense packing than a precise SAT-based check.\ndef is_tetra_overlap_simple(tetra_verts_A, tetra_verts_B):\n    aabb_A = get_aabb(tetra_verts_A)\n    aabb_B = get_aabb(tetra_verts_B)\n    return is_aabb_overlap(aabb_A, aabb_B)\n\n\ndef pack_tetrahedrons(container_vertices, edge_length):\n    # 1. Pre-calculations and Container AABB\n    container_min_xyz = (min(v[0] for v in container_vertices),\n                         min(v[1] for v in container_vertices),\n                         min(v[2] for v in container_vertices))\n    container_max_xyz = (max(v[0] for v in container_vertices),\n                         max(v[1] for v in container_vertices),\n                         max(v[2] for v in container_vertices))\n    \n    container_aabb_dims = vec_sub(container_max_xyz, container_min_xyz)\n    container_aabb_volume = container_aabb_dims[0] * container_aabb_dims[1] * container_aabb_dims[2]\n\n    # Pre-calculate canonical vertices once for the given edge_length\n    canonical_tetra_verts = _get_canonical_tetra_vertices(edge_length)\n    \n    # Important tetrahedron dimensions\n    tetra_circumradius = edge_length * math.sqrt(3/8) # Distance from center to any vertex\n    tetra_bounding_sphere_radius = tetra_circumradius # This is the radius of the smallest sphere enclosing the tetrahedron\n    \n    # 2. Adaptive Strategy based on container volume\n    # These thresholds are heuristics and might need tuning based on actual test cases.\n    # Scaled by (edge_length)^3 to make them volume-dependent\n    small_scale_volume_threshold = (15 * edge_length)**3 \n    medium_scale_volume_threshold = (60 * edge_length)**3\n    \n    # Parameters for placement strategy\n    placement_step_size = edge_length # Default step size for candidate centers\n    rotation_options = [(0, 0, 0)] # Default: one orientation\n    \n    if container_aabb_volume < small_scale_volume_threshold:\n        # Small containers: Finer grid, more rotations\n        placement_step_size = edge_length / 2.0\n        rotation_options = [\n            (0, 0, 0),\n            (math.pi / 2, 0, 0), # 90 deg around X\n            (0, math.pi / 2, 0), # 90 deg around Y\n            (0, 0, math.pi / 2),  # 90 deg around Z\n            (math.pi / 2, math.pi / 2, 0),\n            (0, math.pi / 2, math.pi / 2)\n        ]\n        \n    elif container_aabb_volume < medium_scale_volume_threshold:\n        # Medium containers: Standard grid, fewer rotations\n        placement_step_size = edge_length\n        rotation_options = [\n            (0, 0, 0),\n            (math.pi / 2, 0, 0),\n            (0, math.pi / 2, 0)\n        ]\n    else:\n        # Large/Very Large containers: Coarser grid, minimal rotations, prioritize speed\n        placement_step_size = edge_length * 1.2\n        rotation_options = [(0, 0, 0)] # Just one orientation\n\n    # 3. Spatial Grid for efficient collision detection\n    packed_tetrahedrons_info = [] \n    \n    # Key: (grid_x, grid_y, grid_z) tuple, Value: list of lists of tetra_vertices (AABB is computed on demand)\n    spatial_grid = {}\n    \n    # Size of each cell in the spatial grid for collision checks.\n    # Must be at least 2 * tetra_bounding_sphere_radius to guarantee overlap detection \n    # when checking only the cells touched by a tetrahedron\'s AABB.\n    spatial_grid_cell_size = tetra_bounding_sphere_radius * 2.1 # Slightly larger than diameter for safety\n\n    # Iterate through potential placement centers within a slightly shrunken container AABB\n    # This provides initial clearance for the center point before full vertex checks.\n    iter_min_x = container_min_xyz[0] + tetra_bounding_sphere_radius\n    iter_max_x = container_max_xyz[0] - tetra_bounding_sphere_radius\n    iter_min_y = container_min_xyz[1] + tetra_bounding_sphere_radius\n    iter_max_y = container_max_xyz[1] - tetra_bounding_sphere_radius\n    iter_min_z = container_min_xyz[2] + tetra_bounding_sphere_radius\n    iter_max_z = container_max_xyz[2] - tetra_bounding_sphere_radius\n\n    eps = 1e-9 # Epsilon for floating point comparisons in loops\n\n    current_x = iter_min_x\n    while current_x <= iter_max_x + eps:\n        current_y = iter_min_y\n        while current_y <= iter_max_y + eps:\n            current_z = iter_min_z\n            while current_z <= iter_max_z + eps:\n                candidate_center = (current_x, current_y, current_z)\n                \n                best_rotation = None\n                best_vertices = None # Store vertices for the best rotation to avoid re-calculation\n\n                # Try all rotation options for the current candidate center\n                for rotation in rotation_options:\n                    candidate_vertices = get_tetra_vertices(candidate_center, rotation, edge_length, canonical_tetra_verts)\n                    \n                    # Check if candidate tetrahedron is entirely within container AABB\n                    if not is_tetra_in_container_aabb(candidate_vertices, container_min_xyz, container_max_xyz):\n                        continue \n                    \n                    # Check for overlap with already packed tetrahedrons using the spatial grid\n                    current_tetra_aabb = get_aabb(candidate_vertices)\n                    \n                    overlap_found = False\n                    \n                    # Determine the grid cells that the current_tetra_aabb touches\n                    # Offset by container_min_xyz to map to positive grid coordinates\n                    min_gc_x = int((current_tetra_aabb[0] - container_min_xyz[0]) / spatial_grid_cell_size)\n                    min_gc_y = int((current_tetra_aabb[1] - container_min_xyz[1]) / spatial_grid_cell_size)\n                    min_gc_z = int((current_tetra_aabb[2] - container_min_xyz[2]) / spatial_grid_cell_size)\n                    max_gc_x = int((current_tetra_aabb[3] - container_min_xyz[0]) / spatial_grid_cell_size)\n                    max_gc_y = int((current_tetra_aabb[4] - container_min_xyz[1]) / spatial_grid_cell_size)\n                    max_gc_z = int((current_tetra_aabb[5] - container_min_xyz[2]) / spatial_grid_cell_size)\n\n                    # Iterate over these touched grid cells to find potential collisions\n                    for gx in range(min_gc_x, max_gc_x + 1):\n                        for gy in range(min_gc_y, max_gc_y + 1):\n                            for gz in range(min_gc_z, max_gc_z + 1):\n                                if (gx, gy, gz) in spatial_grid:\n                                    for existing_tetra_verts in spatial_grid[(gx, gy, gz)]:\n                                        if is_tetra_overlap_simple(candidate_vertices, existing_tetra_verts):\n                                            overlap_found = True\n                                            break\n                                if overlap_found:\n                                    break\n                            if overlap_found:\n                                break\n                        if overlap_found:\n                            break\n                    \n                    if not overlap_found:\n                        best_rotation = rotation\n                        best_vertices = candidate_vertices # Store the valid vertices for this best rotation\n                        break # Found a valid rotation, break out of rotation loop and place this tetrahedron\n\n                if best_rotation:\n                    # Place the tetrahedron\n                    packed_tetrahedrons_info.append({\n                        "center": candidate_center,\n                        "rotation": best_rotation\n                    })\n                    \n                    # Add the new tetrahedron\'s vertices to the spatial grid for future collision checks\n                    final_aabb = get_aabb(best_vertices) # Get AABB of the newly placed tetrahedron\n                    \n                    min_gc_x = int((final_aabb[0] - container_min_xyz[0]) / spatial_grid_cell_size)\n                    min_gc_y = int((final_aabb[1] - container_min_xyz[1]) / spatial_grid_cell_size)\n                    min_gc_z = int((final_aabb[2] - container_min_xyz[2]) / spatial_grid_cell_size)\n                    max_gc_x = int((final_aabb[3] - container_min_xyz[0]) / spatial_grid_cell_size)\n                    max_gc_y = int((final_aabb[4] - container_min_xyz[1]) / spatial_grid_cell_size)\n                    max_gc_z = int((final_aabb[5] - container_min_xyz[2]) / spatial_grid_cell_size)\n\n                    for gx in range(min_gc_x, max_gc_x + 1):\n                        for gy in range(min_gc_y, max_gc_y + 1):\n                            for gz in range(min_gc_z, max_gc_z + 1):\n                                if (gx, gy, gz) not in spatial_grid:\n                                    spatial_grid[(gx, gy, gz)] = []\n                                spatial_grid[(gx, gy, gz)].append(best_vertices) # Store actual vertices in the grid\n                    \n                    # Advance current_z by `placement_step_size` to consider the next candidate position.\n                    # This greedy step helps to fill space faster.\n                    current_z += placement_step_size\n                else:\n                    # If no rotation worked for this center, just advance by `placement_step_size` along Z\n                    current_z += placement_step_size\n            current_y += placement_step_size\n        current_x += placement_step_size\n            \n    return packed_tetrahedrons_info'}