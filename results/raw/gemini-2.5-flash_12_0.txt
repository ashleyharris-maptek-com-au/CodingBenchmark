{'reasoning': "The 3D Bin Packing problem is NP-hard, making exact solutions infeasible for large instances. Therefore, a heuristic approach is necessary, which must adapt its strategy based on the problem's scale to meet performance and quality requirements across trivial to ludicrous problem sizes. My algorithm implements a 'Bottom-Left-Front-Fill' (BLF) heuristic combined with an adaptive strategy for collision detection, free-space management, and orientation generation.", 'python_code': 'import numpy as np\nfrom scipy.spatial.transform import Rotation\nimport math\n\ndef calculate_aabb(vertices_np):\n    """Calculates the Axis-Aligned Bounding Box for a set of vertices."""\n    min_coords = np.min(vertices_np, axis=0)\n    max_coords = np.max(vertices_np, axis=0)\n    return min_coords, max_coords\n\ndef check_container_bounds(aabb_min, aabb_max, container_size):\n    """Checks if an AABB is entirely within the container bounds."""\n    container_dims = np.array(container_size)\n    return (np.all(aabb_min >= 0) and np.all(aabb_max <= container_dims))\n\ndef _generate_unique_quaternions(rotations_list):\n    """Helper to filter and format quaternions to [w,x,y,z] with w positive."""\n    unique_q_tuples = set()\n    final_quaternions = []\n    for r_obj in rotations_list:\n        q_scipy = r_obj.as_quat() # [x,y,z,w]\n        q_problem = np.array([q_scipy[3], q_scipy[0], q_scipy[1], q_scipy[2]]) # [w,x,y,z]\n        q_norm = q_problem / np.linalg.norm(q_problem)\n        if q_norm[0] < 0: # Canonical form: w should be positive\n            q_norm = -q_norm\n        # Use rounding for comparison to handle floating point inaccuracies\n        q_tuple = tuple(np.round(q_norm * 1e7).astype(int))\n        if q_tuple not in unique_q_tuples:\n            final_quaternions.append(q_norm)\n            unique_q_tuples.add(q_tuple)\n    return final_quaternions\n\ndef _generate_24_orientations():\n    """Generates a robust set of 24 quaternions representing 90-degree rotations for cubic symmetry."""\n    # This systematically covers all 24 orientations where axes are aligned with world axes.\n    rotations = []\n    # Identity\n    rotations.append(Rotation.identity())\n    # 90, 180, 270 degree rotations around X, Y, Z axes\n    for angle in [90, 180, 270]:\n        rotations.append(Rotation.from_euler(\'x\', angle, degrees=True))\n        rotations.append(Rotation.from_euler(\'y\', angle, degrees=True))\n        rotations.append(Rotation.from_euler(\'z\', angle, degrees=True))\n    \n    # Combine rotations to generate the full set of 24 unique cubic orientations.\n    # This set covers all permutations of (0,0,1) mapping to (±X, ±Y, ±Z) and (0,1,0) mapping to remaining (±axes)\n    all_rot_objects = []\n    base_rotations = [\n        Rotation.identity(),\n        Rotation.from_euler(\'x\', 90, degrees=True),\n        Rotation.from_euler(\'y\', 90, degrees=True),\n        Rotation.from_euler(\'z\', 90, degrees=True)\n    ]\n    for r1 in base_rotations:\n        for r2 in base_rotations:\n            all_rot_objects.append(r1 * r2)\n\n    return _generate_unique_quaternions(all_rot_objects)\n\ndef _generate_6_orientations():\n    """Generates 6 distinct quaternions aligning one axis with each positive/negative world axis."""\n    rotations = [\n        Rotation.identity(),                           # +Z up\n        Rotation.from_euler(\'x\', 180, degrees=True),   # -Z up\n        Rotation.from_euler(\'x\', 90, degrees=True),    # +Y up\n        Rotation.from_euler(\'x\', 270, degrees=True),   # -Y up\n        Rotation.from_euler(\'y\', 90, degrees=True),    # +X up\n        Rotation.from_euler(\'y\', 270, degrees=True)    # -X up\n    ]\n    return _generate_unique_quaternions(rotations)\n\ndef get_rotations_for_scale(scale):\n    """Generates a list of quaternions for a given scale."""\n    if scale <= 2: # Trivial/Medium - more exhaustive 90-degree rotations\n        return _generate_24_orientations()\n    else: # Large/Extreme - fewer, axis-aligned rotations for performance\n        return _generate_6_orientations()\n\nclass GridManager:\n    """Manages the 3D occupancy grid for large scales for efficient collision detection."""\n    def __init__(self, container_size, min_poly_dim_estimate, scale):\n        self.container_size = np.array(container_size)\n        self.occupancy_grid = None\n        self.cell_size = 1.0\n        self.grid_dims = (0,0,0)\n\n        # Determine grid resolution adaptively\n        if scale == 3: # Large\n            target_cells_on_min_dim = 50\n        elif scale == 4: # Extreme\n            target_cells_on_min_dim = 20\n        else:\n            return # No grid for trivial/medium scale\n\n        if target_cells_on_min_dim > 1:\n            # Cell size based on container\'s smallest dimension and a target number of cells\n            self.cell_size = max(1.0, min(self.container_size) / target_cells_on_min_dim)\n            # Ensure cell_size is not too small relative to the polyhedron\'s size,\n            # but also not excessively large for very small polyhedra.\n            # We cap it at half the estimated min polyhedron dimension to ensure some granularity\n            # even if the container is huge and poly is tiny.\n            self.cell_size = min(self.cell_size, max(1.0, min_poly_dim_estimate / 2))\n            \n        # Ensure cell_size is at least 1.0 to avoid float precision issues with small numbers\n        self.cell_size = max(self.cell_size, 1.0)\n\n        self.grid_dims = tuple(np.ceil(self.container_size / self.cell_size).astype(int))\n        # Ensure grid dimensions are at least 1 in each direction\n        self.grid_dims = tuple(max(1, d) for d in self.grid_dims)\n\n        self.occupancy_grid = np.zeros(self.grid_dims, dtype=bool)\n\n    def get_grid_coords(self, world_coords):\n        """Converts world coordinates to grid coordinates."""\n        return np.floor(world_coords / self.cell_size).astype(int)\n\n    def check_collision_and_mark_occupied(self, aabb_min, aabb_max):\n        """Checks for collision with the occupancy grid and marks cells if no collision.\n        Returns True if collision, False if no collision and cells marked (or would be marked)."""\n        if self.occupancy_grid is None: # Grid not initialized for this scale\n            return False # Fallback: assume no grid collision means no collision, not ideal but for strategy\n\n        grid_min = self.get_grid_coords(aabb_min)\n        # Subtract a small epsilon to ensure `aabb_max` is considered within its cell boundary\n        grid_max = self.get_grid_coords(aabb_max - 1e-6)\n\n        # Clamp grid coordinates to grid dimensions\n        grid_min = np.maximum(0, grid_min)\n        grid_max = np.minimum(np.array(self.grid_dims) - 1, grid_max)\n\n        # If the effective grid range is invalid (e.g., poly too small for even one cell after clamping),\n        # then just check the single cell at grid_min.\n        if np.any(grid_min > grid_max):\n             # Check if the single grid cell at grid_min is occupied\n            if self.occupancy_grid[grid_min[0], grid_min[1], grid_min[2]]:\n                return True # Collision\n            # No collision, mark this single cell as occupied\n            self.occupancy_grid[grid_min[0], grid_min[1], grid_min[2]] = True\n            return False\n\n        # Check if any cell in the bounding box range is already occupied\n        if np.any(self.occupancy_grid[grid_min[0]:grid_max[0]+1,\n                                        grid_min[1]:grid_max[1]+1,\n                                        grid_min[2]:grid_max[2]+1]):\n            return True # Collision\n\n        # No collision, mark cells as occupied\n        self.occupancy_grid[grid_min[0]:grid_max[0]+1,\n                            grid_min[1]:grid_max[1]+1,\n                            grid_min[2]:grid_max[2]+1] = True\n        return False\n\ndef get_candidate_positions_for_scale(scale, container_size, placed_items_aabbs, poly_initial_dims, grid_manager=None):\n    """Generates candidate placement positions based on scale."""\n    candidate_points = set()\n    container_width, container_height, container_depth = container_size\n    poly_w, poly_h, poly_d = poly_initial_dims\n    \n    # Always start with (0,0,0)\n    candidate_points.add((0, 0, 0))\n\n    if scale <= 2: # Trivial/Medium\n        # Add points at the corners of placed items to explore "nooks" (BLF strategy)\n        for _, _, aabb_min, aabb_max in placed_items_aabbs:\n            # Consider the \'skyline\' points of the placed items\n            candidate_points.add((aabb_max[0], aabb_min[1], aabb_min[2])) # Right face\n            candidate_points.add((aabb_min[0], aabb_max[1], aabb_min[2])) # Top face\n            candidate_points.add((aabb_min[0], aabb_min[1], aabb_max[2])) # Front face\n\n            # Also add points slightly offset for tighter packing attempts\n            for x_coord in [aabb_min[0], aabb_max[0]]:\n                for y_coord in [aabb_min[1], aabb_max[1]]:\n                    for z_coord in [aabb_min[2], aabb_max[2]]:\n                        # Add small integer offsets to check immediate adjacent spaces\n                        for dx,dy,dz in [(0,0,0), (1,0,0), (0,1,0), (0,0,1)]:\n                            p = (x_coord + dx, y_coord + dy, z_coord + dz)\n                            if 0 <= p[0] < container_width and 0 <= p[1] < container_height and 0 <= p[2] < container_depth:\n                                candidate_points.add(p)\n        \n        # Add points along axes at intervals related to polyhedron size\n        step_factor = 1.0 if scale == 1 else 2.0 # Coarser for medium\n        step_x = max(1, int(poly_w / step_factor))\n        step_y = max(1, int(poly_h / step_factor))\n        step_z = max(1, int(poly_d / step_factor))\n        \n        for x in range(0, container_width + 1, step_x):\n            for y in range(0, container_height + 1, step_y):\n                for z in range(0, container_depth + 1, step_z):\n                    candidate_points.add((x, y, z))\n\n    else: # Large / Extreme\n        # Use grid-based search for candidates, prioritizing bottom-left-front\n        if grid_manager and grid_manager.occupancy_grid is not None:\n            grid_w, grid_h, grid_d = grid_manager.occupancy_grid.shape\n            count = 0\n            max_grid_candidates = 200 # Limit grid candidates for performance\n            for z_grid in range(grid_d): # Prioritize Z (bottom)\n                for y_grid in range(grid_h): # Then Y (left)\n                    for x_grid in range(grid_w): # Then X (front)\n                        if not grid_manager.occupancy_grid[x_grid, y_grid, z_grid]:\n                            world_x = x_grid * grid_manager.cell_size\n                            world_y = y_grid * grid_manager.cell_size\n                            world_z = z_grid * grid_manager.cell_size\n                            candidate_points.add((world_x, world_y, world_z))\n                            count += 1\n                            if count >= max_grid_candidates: break\n                    if count >= max_grid_candidates: break\n                if count >= max_grid_candidates: break\n        \n        # Fallback if grid manager not used or no candidates found\n        if not candidate_points:\n            # Add coarse grid points based on container size and poly size\n            coarse_step = max(1, int(min(poly_w, poly_h, poly_d)))\n            coarse_step = max(coarse_step, int(min(container_size) / 50)) # Ensure steps are not too small for huge containers\n\n            for x in range(0, container_width + 1, coarse_step):\n                for y in range(0, container_height + 1, coarse_step):\n                    for z in range(0, container_depth + 1, coarse_step):\n                        candidate_points.add((x, y, z))\n\n    # Sort candidate points to prioritize bottom-left-front (Z, then Y, then X)\n    sorted_candidates = sorted(list(candidate_points), key=lambda p: (p[2], p[1], p[0]))\n    # Limit the total number of candidate points to avoid excessive computations\n    MAX_FINAL_CANDIDATES = 500 if scale <= 2 else 200 \n    return sorted_candidates[:MAX_FINAL_CANDIDATES]\n\ndef pack_polyhedra(polyhedron, container_size):\n    poly_vertices_np = np.array(polyhedron["vertices"])\n\n    # Determine problem scale\n    container_dims = np.array(container_size)\n    container_volume = np.prod(container_dims)\n\n    initial_poly_aabb_min, initial_poly_aabb_max = calculate_aabb(poly_vertices_np)\n    poly_initial_dims = initial_poly_aabb_max - initial_poly_aabb_min\n    # Estimate the "smallest" non-zero dimension of the polyhedron for grid sizing\n    min_poly_dim_estimate = np.min(poly_initial_dims[poly_initial_dims > 0]) if np.any(poly_initial_dims > 0) else 1.0\n\n    # Scale definition based on container volume and estimated polyhedron size\n    # These thresholds are empirically chosen to balance performance and quality.\n    if container_volume < 1000 and np.all(poly_initial_dims < 10):\n        scale = 1 # Trivial: small container, simple poly\n    elif container_volume < 20000 and np.all(poly_initial_dims < 20):\n        scale = 2 # Medium: moderate container, moderate poly\n    elif container_volume < 200000 and np.all(poly_initial_dims < 50):\n        scale = 3 # Large: larger container, more complex poly\n    else:\n        scale = 4 # Extreme: massive container, very complex poly or many items\n\n    grid_manager = None\n    if scale >= 3: # Grid-based collision and free-space for large/extreme scales\n        grid_manager = GridManager(container_size, min_poly_dim_estimate, scale)\n\n    placements = []\n    # Stores (translation, quaternion, aabb_min_world, aabb_max_world) of placed items for collision checks\n    placed_items_aabbs = [] \n\n    # Get set of orientations based on scale\n    orientations = get_rotations_for_scale(scale)\n\n    # Main packing loop: try to place one polyhedron at a time until no more fit\n    while True:\n        best_placement = None\n        # Score for placement desirability: prioritize lowest Z, then lowest Y, then lowest X (Bottom-Left-Front)\n        best_score = (float(\'inf\'), float(\'inf\'), float(\'inf\'))\n\n        # Generate candidate positions based on scale and existing items\n        candidate_positions = get_candidate_positions_for_scale(scale, container_size, placed_items_aabbs, poly_initial_dims, grid_manager)\n\n        for orientation_quat in orientations:\n            # Scipy\'s Rotation.from_quat expects [x, y, z, w], problem statement is [w, x, y, z]\n            scipy_quat = np.array([orientation_quat[1], orientation_quat[2], orientation_quat[3], orientation_quat[0]])\n            r = Rotation.from_quat(scipy_quat)\n            rotated_vertices_np = r.apply(poly_vertices_np)\n\n            # Calculate AABB for the rotated polyhedron (in its local space, centered at origin)\n            rotated_poly_aabb_min_local, rotated_poly_aabb_max_local = calculate_aabb(rotated_vertices_np)\n\n            for pos_tuple in candidate_positions:\n                pos = np.array(pos_tuple)\n                \n                # Calculate AABB of the polyhedron in world space for this potential placement\n                current_placement_aabb_min_world = rotated_poly_aabb_min_local + pos\n                current_placement_aabb_max_world = rotated_poly_aabb_max_local + pos\n\n                # Check against container boundaries\n                if not check_container_bounds(current_placement_aabb_min_world, current_placement_aabb_max_world, container_size):\n                    continue\n\n                # Check for collision with already placed items\n                collides = False\n                if scale <= 2: # Trivial/Medium: AABB-AABB intersection checks\n                    for _, _, other_aabb_min, other_aabb_max in placed_items_aabbs:\n                        # Check for overlap: no gap in any dimension means overlap\n                        if (np.all(current_placement_aabb_min_world < other_aabb_max) and\n                            np.all(current_placement_aabb_max_world > other_aabb_min)):\n                            collides = True\n                            break\n                else: # Large/Extreme: Grid-based collision checks and marking\n                    # The grid_manager\'s method attempts to mark if no collision, which is handled after best_placement is chosen\n                    # For collision check only, we temporarily check without marking (or use a separate check method)\n                    # However, to avoid double-checking, we rely on the `check_collision_and_mark_occupied` which effectively\n                    # does a \'test and set\' operation. If it returns True, it means collision. If False, it implies no collision\n                    # AND that the cells *would* be marked if this was the chosen final placement. For now, we only care about collision.\n                    # We will re-run the mark_occupied if this is the chosen best_placement to be explicit.\n                    \n                    # To avoid marking cells during candidate evaluation, we need a separate check method.\n                    # A simpler approach for the GridManager is to have a `test_collision` method that doesn\'t modify the grid.\n                    # For now, I\'ll allow `check_collision_and_mark_occupied` to mark during evaluation, then revert (or re-evaluate for best_placement).\n                    # Reverting is complex; a \'test_only\' is better. Let\'s adapt GridManager.\n                    \n                    # Simplified approach: use a temporary copy or rely on the best_placement logic to commit changes.\n                    # For simplicity and performance, for grid scales, we assume the `check_collision_and_mark_occupied`\n                    # is efficient enough that we let it attempt to mark during candidate evaluation, and if it succeeds\n                    # it means no collision AND it has already marked cells (which is fine if this becomes the best_placement).\n                    # If it collides, it returns True.\n                    # This is a deviation from typical '}