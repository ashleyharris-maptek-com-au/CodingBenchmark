{'reasoning': "To satisfy the requirements of scaling from trivial (6 nodes) to extreme (10,000 nodes) while maintaining performance and quality, I employ a hierarchical, adaptive strategy.\n\n1. **Component Decomposition**: The graph is split into connected components. This allows efficient handling of disconnected graphs and prevents 'flying' nodes. Components are laid out independently and then packed using a bounding-box bin packing strategy.\n\n2. **Adaptive Layout Solver**: The layout algorithm changes based on component size:\n   - **Small/Medium (N < 150)**: A full Fruchterman-Reingold force-directed algorithm is used with O(N^2) all-pairs repulsion. This guarantees high-quality, symmetric layouts for trees and cycles.\n   - **Large/Extreme (N >= 150)**: An O(N^2) approach is too slow. I use a 'Stochastic Force-Directed' approach:\n     - **Initialization**: Nodes are initialized using a BFS-based radial layout (placing nodes in concentric layers based on distance from a central pivot). This provides a good global structure immediately, avoiding the tangled 'hairball' local minimum common in random initializations.\n     - **Simulation**: I run a limited number of force-directed iterations where repulsive forces are approximated by sampling a small random subset of nodes (e.g., 10-20) for each node, rather than all neighbors. This reduces repulsion complexity to O(N).\n\n3. **Performance Optimization**: Use of pure Python lists and local variable caching (avoiding dictionary lookups inside inner loops) ensures the code runs within the 30-second limit even for 10,000 nodes.", 'python_code': 'import math\nimport random\n\ndef layout_graph(num_nodes, edges):\n    """\n    Computes a layout for a graph minimizing edge crossings.\n    Adapts algorithm complexity based on graph size.\n    """\n    if num_nodes == 0:\n        return []\n    if num_nodes == 1:\n        return [(0.0, 0.0)]\n\n    # 1. Data Structure Setup\n    adj = [[] for _ in range(num_nodes)]\n    for u, v in edges:\n        if u != v:  # Ignore self-loops for topology\n            adj[u].append(v)\n            adj[v].append(u)\n\n    # 2. Component Decomposition\n    visited = [False] * num_nodes\n    components = []\n    for i in range(num_nodes):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            comp_nodes = []\n            while stack:\n                u = stack.pop()\n                comp_nodes.append(u)\n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            components.append(comp_nodes)\n\n    # Sort components by size (largest first for packing)\n    components.sort(key=len, reverse=True)\n\n    # 3. Layout Each Component\n    final_coords = [(0.0, 0.0)] * num_nodes\n    \n    # Packing variables\n    current_x = 0.0\n    current_y = 0.0\n    row_h = 0.0\n    # Heuristic canvas width for bin packing\n    canvas_limit = math.sqrt(num_nodes) * 50\n    \n    for comp in components:\n        n_comp = len(comp)\n        \n        # Map global IDs to local 0..k-1\n        local_id_map = {node_id: i for i, node_id in enumerate(comp)}\n        local_adj = [[] for _ in range(n_comp)]\n        for u in comp:\n            u_local = local_id_map[u]\n            for v in adj[u]:\n                if v in local_id_map:\n                    local_adj[u_local].append(local_id_map[v])\n\n        # Determine Layout Strategy based on size\n        # Scale area: larger graphs need more space to reduce density\n        scale = 10.0 if n_comp < 10 else math.sqrt(n_comp) * 5.0\n        width = max(n_comp * 2, 50.0)\n        height = width\n        \n        if n_comp == 1:\n            lx, ly = [0.0], [0.0]\n        elif n_comp < 150:\n            # High Quality: Full Fruchterman-Reingold\n            lx, ly = force_directed_full(n_comp, local_adj, width, height)\n        else:\n            # High Scale: BFS Init + Stochastic Sampling FR\n            lx, ly = force_directed_fast(n_comp, local_adj, width, height)\n\n        # Normalize component to (0,0)\n        min_x, min_y = min(lx), min(ly)\n        max_x, max_y = max(lx), max(ly)\n        \n        comp_w = max_x - min_x\n        comp_h = max_y - min_y\n        \n        # Bin Packing\n        if current_x + comp_w > canvas_limit and current_x > 0:\n            current_x = 0.0\n            current_y += row_h + 50.0 # New row with padding\n            row_h = 0.0\n        \n        # Assign Global Coordinates\n        for i, node_id in enumerate(comp):\n            final_coords[node_id] = (\n                lx[i] - min_x + current_x,\n                ly[i] - min_y + current_y\n            )\n            \n        current_x += comp_w + 50.0 # Padding\n        row_h = max(row_h, comp_h)\n\n    return final_coords\n\n\ndef force_directed_full(n, adj, width, height):\n    """Standard Fruchterman-Reingold with O(N^2) repulsion for small graphs."""\n    area = width * height\n    k = math.sqrt(area / n)\n    iterations = 50\n    start_temp = width / 10.0\n    \n    # Random Init\n    xs = [random.uniform(0, width) for _ in range(n)]\n    ys = [random.uniform(0, height) for _ in range(n)]\n    \n    # Precompute edge list for faster iteration\n    edges = []\n    for u in range(n):\n        for v in adj[u]:\n            if u < v:\n                edges.append((u, v))\n    \n    k_sq = k * k\n\n    for it in range(iterations):\n        temp = start_temp * (1.0 - it / iterations)\n        if temp <= 0: break\n        \n        dx = [0.0] * n\n        dy = [0.0] * n\n        \n        # Repulsion (All Pairs)\n        for i in range(n):\n            for j in range(i + 1, n):\n                delta_x = xs[i] - xs[j]\n                delta_y = ys[i] - ys[j]\n                dist_sq = delta_x * delta_x + delta_y * delta_y\n                \n                if dist_sq < 0.01: \n                    dist_sq = 0.01\n                    delta_x, delta_y = 0.1, 0.1\n                    \n                dist = math.sqrt(dist_sq)\n                force = k_sq / dist\n                \n                fx = (delta_x / dist) * force\n                fy = (delta_y / dist) * force\n                \n                dx[i] += fx\n                dy[i] += fy\n                dx[j] -= fx\n                dy[j] -= fy\n\n        # Attraction\n        for u, v in edges:\n            delta_x = xs[u] - xs[v]\n            delta_y = ys[u] - ys[v]\n            dist_sq = delta_x * delta_x + delta_y * delta_y\n            dist = math.sqrt(dist_sq)\n            if dist < 0.01: dist = 0.01\n            \n            force = dist_sq / k\n            fx = (delta_x / dist) * force\n            fy = (delta_y / dist) * force\n            \n            dx[u] -= fx\n            dy[u] -= fy\n            dx[v] += fx\n            dy[v] += fy\n            \n        # Apply\n        for i in range(n):\n            disp_sq = dx[i]*dx[i] + dy[i]*dy[i]\n            disp = math.sqrt(disp_sq)\n            if disp > 0:\n                lim = min(disp, temp)\n                xs[i] += (dx[i] / disp) * lim\n                ys[i] += (dy[i] / disp) * lim\n                \n    return xs, ys\n\n\ndef force_directed_fast(n, adj, width, height):\n    """Scalable layout: BFS Init + Sampled Repulsion for large graphs."""\n    # 1. BFS Initialization (Radial Layout)\n    # Find a pseudo-center (node with high degree)\n    center = 0\n    max_deg = -1\n    for i in range(n):\n        if len(adj[i]) > max_deg:\n            max_deg = len(adj[i])\n            center = i\n            \n    layers = [-1] * n\n    layers[center] = 0\n    queue = [center]\n    max_layer = 0\n    \n    # Standard BFS\n    head = 0\n    while head < len(queue):\n        u = queue[head]\n        head += 1\n        l = layers[u]\n        if l > max_layer: max_layer = l\n        for v in adj[u]:\n            if layers[v] == -1:\n                layers[v] = l + 1\n                queue.append(v)\n                \n    # Assign coords based on layers (Spiral/Concentric)\n    xs = [0.0] * n\n    ys = [0.0] * n\n    layer_nodes = [[] for _ in range(max_layer + 1)]\n    for i in range(n):\n        layer_nodes[layers[i]].append(i)\n        \n    radius_step = width / (max_layer + 2) if max_layer > 0 else 10.0\n    \n    for l_idx, nodes in enumerate(layer_nodes):\n        r = radius_step * (l_idx + 1)\n        count = len(nodes)\n        for i, node in enumerate(nodes):\n            angle = 2 * math.pi * i / count\n            xs[node] = width/2 + r * math.cos(angle)\n            ys[node] = height/2 + r * math.sin(angle)\n\n    # 2. Stochastic Force Directed\n    # Reduce iterations and sampling for speed\n    iterations = 30 if n < 1000 else 15\n    sample_size = 15 # Only repel from 15 random nodes\n    \n    area = width * height\n    k = math.sqrt(area / n)\n    k_sq = k * k\n    start_temp = width / 4.0\n    \n    # Flatten edges\n    edges = []\n    for u in range(n):\n        for v in adj[u]:\n            if u < v:\n                edges.append((u, v))\n    \n    # To avoid iterating massive edge lists in very dense graphs, limit edges if necessary\n    # But for N=10000, E usually < 100,000, which is manageable.\n    \n    for it in range(iterations):\n        temp = start_temp * (1.0 - it / iterations)\n        if temp <= 0: break\n        \n        dx = [0.0] * n\n        dy = [0.0] * n\n        \n        # Stochastic Repulsion\n        for i in range(n):\n            # Sample a few random indices\n            # We implement a linear congruential generator or simple random for speed\n            # Using standard random.randint is fine here\n            for _ in range(sample_size):\n                j = random.randint(0, n - 1)\n                if i == j: continue\n                \n                delta_x = xs[i] - xs[j]\n                delta_y = ys[i] - ys[j]\n                dist_sq = delta_x*delta_x + delta_y*delta_y\n                \n                if dist_sq < 1.0: \n                    dist_sq = 1.0\n                    delta_x = 0.5\n                \n                # Use simplified force to avoid sqrt if possible, but sqrt is safer for stability\n                dist = math.sqrt(dist_sq)\n                force = k_sq / dist\n                \n                dx[i] += (delta_x / dist) * force\n                dy[i] += (delta_y / dist) * force\n\n        # Attraction\n        for u, v in edges:\n            delta_x = xs[u] - xs[v]\n            delta_y = ys[u] - ys[v]\n            dist_sq = delta_x*delta_x + delta_y*delta_y\n            dist = math.sqrt(dist_sq)\n            if dist < 1.0: dist = 1.0\n            \n            force = dist_sq / k\n            fx = (delta_x / dist) * force\n            fy = (delta_y / dist) * force\n            \n            dx[u] -= fx\n            dy[u] -= fy\n            dx[v] += fx\n            dy[v] += fy\n            \n        # Apply\n        for i in range(n):\n            disp_sq = dx[i]*dx[i] + dy[i]*dy[i]\n            disp = math.sqrt(disp_sq)\n            if disp > 0:\n                lim = min(disp, temp)\n                xs[i] += (dx[i] / disp) * lim\n                ys[i] += (dy[i] / disp) * lim\n                \n    return xs, ys'}