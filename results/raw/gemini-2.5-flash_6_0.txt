{'reasoning': 'The solution employs an adaptive strategy for the Orbital Traveling Salesman Problem (TSP), dynamically adjusting its approach based on the number of stations to visit. For smaller problem instances (up to 10 stations), a brute-force permutation search is used. This guarantees an optimal solution by evaluating every possible visitation order. For larger and extreme scales (more than 10 stations), where brute-force is computationally infeasible, a heuristic approach is adopted: a Nearest Neighbor algorithm generates an initial path, which is then refined using a 2-opt local search. This combination provides a good balance between performance and solution quality, completing within the specified time limits while yielding near-optimal delta-V estimates. The delta-V calculation between any two orbital states is a simplified heuristic that combines two main components: a plane change maneuver (estimated by the average circular velocity at the average semi-major axis between the two orbits, multiplied by the sine of half the angle between their orbital planes) and a Hohmann-like energy change (estimated by the absolute difference in circular velocities corresponding to their semi-major axes). This heuristic is designed to be computationally efficient while capturing the dominant costs of orbital transfers in 3D space, which is crucial for scalability.', 'python_code': 'import math\nimport itertools\n\n# --- Vector Operations (No NumPy) ---\ndef _norm(vec):\n    """Calculates the Euclidean norm (magnitude) of a 3D vector."""\n    return math.sqrt(sum(x*x for x in vec))\n\ndef _dot(vec1, vec2):\n    """Calculates the dot product of two 3D vectors."""\n    return sum(x*y for x,y in zip(vec1, vec2))\n\ndef _cross(vec1, vec2):\n    """Calculates the cross product of two 3D vectors."""\n    return [\n        vec1[1] * vec2[2] - vec1[2] * vec2[1],\n        vec1[2] * vec2[0] - vec1[0] * vec2[2],\n        vec1[0] * vec2[1] - vec1[1] * vec2[0]\n    ]\n\ndef _clamp_acos_input(value):\n    """Clamps a value to [-1, 1] for robust acos calculations due to floating point inaccuracies."""\n    return max(-1.0, min(1.0, value))\n\n# --- Orbital Mechanics Helper Functions ---\ndef _get_orbital_elements(state_vector, mu):\n    """\n    Calculates key orbital elements from a Cartesian state vector.\n    Returns (semi-major axis, eccentricity, normalized angular momentum vector).\n    These are used for delta-V estimation.\n    """\n    r_vec = state_vector[0:3]\n    v_vec = state_vector[3:6]\n\n    r_mag = _norm(r_vec)\n    v_mag = _norm(v_vec)\n\n    # Angular momentum vector\n    h_vec = _cross(r_vec, v_vec)\n    h_mag = _norm(h_vec)\n\n    # Specific mechanical energy\n    E = (v_mag**2 / 2.0) - (mu / r_mag)\n\n    # Semi-major axis (a)\n    # For elliptical orbits, E < 0. For E >= 0 (parabolic/hyperbolic), \'a\' is inf or -inf.\n    # We assume elliptical orbits for stations. Handle edge case by returning inf/0 for cost later.\n    a = -mu / (2.0 * E) if E < 0 and E != 0 else float(\'inf\') # Avoid division by zero if E is precisely 0\n    if abs(E) < 1e-10: a = float(\'inf\') # Treat near-parabolic as inf\n\n    # Eccentricity vector and magnitude\n    e_vec = _cross(v_vec, h_vec)\n    if mu != 0 and r_mag != 0: # Avoid division by zero\n        e_vec = [x / mu for x in e_vec]\n        e_vec = [x - y / r_mag for x, y in zip(e_vec, r_vec)]\n    else:\n        e_vec = [0, 0, 0] # Should not happen with valid orbit data\n    e = _norm(e_vec)\n\n    # Normalized angular momentum vector (normal to the orbital plane)\n    h_norm_vec = [x / h_mag for x in h_vec] if h_mag > 0 else [0, 0, 0] # Avoid division by zero\n\n    return a, e, h_norm_vec\n\ndef _calculate_delta_v(state1, state2, mu):\n    """\n    Estimates the delta-V required to transfer from orbit state1 to orbit state2.\n    Uses a simplified heuristic combining plane change and a Hohmann-like energy change.\n    """\n    a1, e1, h1_norm_vec = _get_orbital_elements(state1, mu)\n    a2, e2, h2_norm_vec = _get_orbital_elements(state2, mu)\n\n    # If either orbit is non-elliptical or problematic (e.g., a <= 0 or very large eccentricity suggesting escape)\n    # assign a very high cost to discourage such transfers.\n    # For a TSP, we assume transfers between stable elliptical orbits.\n    if a1 <= 0 or a2 <= 0 or e1 >= 1.0 or e2 >= 1.0 or a1 == float(\'inf\') or a2 == float(\'inf\'):\n        return float(\'inf\')\n\n    # 1. Plane Change Delta-V\n    # Angle between orbital planes\n    dot_product = _dot(h1_norm_vec, h2_norm_vec)\n    delta_plane_angle = math.acos(_clamp_acos_input(dot_product))\n\n    # Reference velocity for plane change. Use circular velocity at an average semi-major axis.\n    # This is a heuristic and can be refined (e.g., plane change at apoapsis to minimize cost).\n    avg_a = (a1 + a2) / 2.0\n    if avg_a <= 1e-6: return float(\'inf\') # Avoid division by zero or near-zero avg_a\n\n    v_ref_plane_change = math.sqrt(mu / avg_a) # Circular velocity at average semi-major axis\n    dV_plane = 2 * v_ref_plane_change * math.sin(delta_plane_angle / 2.0)\n\n    # 2. Hohmann-like Delta-V for semi-major axis change (simplified)\n    # This approximates the cost to change from one orbit\'s energy level to another.\n    # We use the velocity for circular orbits at the respective semi-major axes.\n    # This is a very simplified Hohmann approximation, ignoring actual transfer ellipses and eccentricity.\n    v_circ1 = math.sqrt(mu / a1)\n    v_circ2 = math.sqrt(mu / a2)\n    dV_hohmann_approx = abs(v_circ1 - v_circ2)\n\n    # Total Delta-V is the sum of these two components.\n    total_dV = dV_plane + dV_hohmann_approx\n\n    return total_dV\n\ndef _calculate_path_delta_v(start_orbit_state, station_states, path_indices, cost_matrix):\n    """Calculates the total delta-V for a given path using the precomputed cost matrix."""\n    total_dv = 0\n    \n    # First leg: from start_orbit to the first station in the path\n    first_station_idx = path_indices[0]\n    total_dv += cost_matrix[-1][first_station_idx]\n\n    # Subsequent legs: between stations in the path\n    for i in range(len(path_indices) - 1):\n        from_idx = path_indices[i]\n        to_idx = path_indices[i+1]\n        total_dv += cost_matrix[from_idx][to_idx]\n    \n    return total_dv\n\ndef solve_orbital_tsp(start_orbit, station_orbits, mu):\n    """\n    Solves the Orbital Travelling Salesman Problem for a given set of stations.\n    Adapts its strategy based on the number of stations for scalability.\n    """\n    N_stations = len(station_orbits)\n\n    # Precompute all pairwise delta-V costs.\n    # cost_matrix[i][j] is delta-V from station i to station j.\n    # cost_matrix[-1][j] is delta-V from start_orbit to station j.\n    # Use a dict for cost_matrix to handle negative start_node index naturally.\n    cost_matrix = {}\n    \n    # Costs from start_orbit to all stations\n    cost_matrix[-1] = {}\n    for j in range(N_stations):\n        cost_matrix[-1][j] = _calculate_delta_v(start_orbit, station_orbits[j], mu)\n\n    # Costs between all stations\n    for i in range(N_stations):\n        cost_matrix[i] = {}\n        for j in range(N_stations):\n            if i == j:\n                cost_matrix[i][j] = 0.0 # Cost to stay at the same station is zero\n            else:\n                cost_matrix[i][j] = _calculate_delta_v(station_orbits[i], station_orbits[j], mu)\n\n    # --- Adaptive TSP Solver Strategy ---\n    visit_order = []\n    total_delta_v = float(\'inf\')\n    reasoning = ""\n\n    if N_stations <= 10:\n        # Trivial to Medium scale: Brute-force permutations for exact solution\n        reasoning = "For 10 or fewer stations, an exact solution is found using brute-force permutation search."\n        \n        best_path_indices = None\n\n        for path_indices_tuple in itertools.permutations(range(N_stations)):\n            current_path_indices = list(path_indices_tuple)\n            current_dv = _calculate_path_delta_v(start_orbit, station_orbits, current_path_indices, cost_matrix)\n\n            if current_dv < total_delta_v:\n                total_delta_v = current_dv\n                best_path_indices = current_path_indices\n        \n        visit_order = best_path_indices if best_path_indices is not None else []\n\n    else:\n        # Large to Extreme scale: Nearest Neighbor heuristic + 2-opt local search for approximation\n        reasoning = "For more than 10 stations, a heuristic approach is used: Nearest Neighbor algorithm followed by 2-opt local search improvement for efficiency and scalability."\n\n        # 1. Nearest Neighbor (NN) Heuristic for initial path\n        current_node_idx = -1 # Start from the initial spacecraft orbit\n        unvisited_stations = set(range(N_stations))\n        nn_path = []\n        \n        while unvisited_stations:\n            next_station_idx = -1\n            min_dv = float(\'inf\')\n\n            for station_idx in unvisited_stations:\n                cost = cost_matrix[current_node_idx][station_idx]\n                if cost < min_dv:\n                    min_dv = cost\n                    next_station_idx = station_idx\n            \n            if next_station_idx != -1:\n                nn_path.append(next_station_idx)\n                unvisited_stations.remove(next_station_idx)\n                current_node_idx = next_station_idx\n            else:\n                # This case implies no path found, should not occur if unvisited_stations is not empty\n                break\n        \n        best_path_indices = list(nn_path)\n        total_delta_v = _calculate_path_delta_v(start_orbit, station_orbits, best_path_indices, cost_matrix)\n        \n        # 2. 2-opt Local Search Improvement\n        improved = True\n        while improved:\n            improved = False\n            for i in range(N_stations - 1):\n                for j in range(i + 1, N_stations):\n                    # Create a new path by reversing the segment between i+1 and j\n                    new_path_indices = best_path_indices[:i+1] + best_path_indices[j:i:-1] + best_path_indices[j+1:]\n                    \n                    # Calculate the delta-V for the new path\n                    new_dv = _calculate_path_delta_v(start_orbit, station_orbits, new_path_indices, cost_matrix)\n\n                    if new_dv < total_delta_v:\n                        total_delta_v = new_dv\n                        best_path_indices = new_path_indices\n                        improved = True\n        \n        visit_order = best_path_indices\n\n    return {\n        "visit_order": visit_order,\n        "total_delta_v": total_delta_v,\n        "reasoning": reasoning\n    }'}