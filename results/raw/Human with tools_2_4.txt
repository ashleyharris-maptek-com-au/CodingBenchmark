{'reasoning': "Using greedy approach for Chinese Postman: 1) Find all odd-degree vertices. 2) Greedily pair them by shortest path (BFS, not optimal matching). 3) Duplicate edges along paired paths. 4) Find Eulerian circuit using Hierholzer's algorithm. This is suboptimal because greedy pairing doesn't minimize total duplicate cost.", 'python_code': 'from collections import defaultdict, deque\n\ndef solve_cpp(num_nodes, edges):\n    """\n    Solve Chinese Postman Problem using greedy approach.\n    Returns the route as a list of node indices.\n    """\n    # Build adjacency list with edge counts (multigraph support)\n    adj = defaultdict(list)\n    edge_count = defaultdict(int)\n    \n    for a, b, w in edges:\n        adj[a].append((b, w))\n        adj[b].append((a, w))\n        edge_key = tuple(sorted([a, b]))\n        edge_count[edge_key] += 1\n    \n    # Find vertices with odd degree\n    degree = defaultdict(int)\n    for a, b, w in edges:\n        degree[a] += 1\n        degree[b] += 1\n    \n    odd_vertices = [v for v in range(num_nodes) if degree[v] % 2 == 1]\n    \n    # Greedy pairing of odd vertices - add shortest paths\n    # Use BFS to find shortest paths\n    def bfs_path(start, end):\n        if start == end:\n            return [start]\n        visited = {start: None}\n        queue = deque([start])\n        while queue:\n            node = queue.popleft()\n            for neighbor, _ in adj[node]:\n                if neighbor not in visited:\n                    visited[neighbor] = node\n                    if neighbor == end:\n                        path = [end]\n                        while path[-1] != start:\n                            path.append(visited[path[-1]])\n                        return path[::-1]\n                    queue.append(neighbor)\n        return None\n    \n    # Add duplicate edges for odd vertex pairs (greedy)\n    extra_edges = []\n    remaining = odd_vertices[:]\n    while len(remaining) >= 2:\n        v = remaining.pop(0)\n        # Find closest odd vertex\n        best_u = None\n        best_path = None\n        best_len = float(\'inf\')\n        for u in remaining:\n            path = bfs_path(v, u)\n            if path and len(path) < best_len:\n                best_len = len(path)\n                best_u = u\n                best_path = path\n        if best_u:\n            remaining.remove(best_u)\n            # Add edges along the path\n            for i in range(len(best_path) - 1):\n                a, b = best_path[i], best_path[i + 1]\n                edge_key = tuple(sorted([a, b]))\n                edge_count[edge_key] += 1\n    \n    # Build multigraph adjacency for Hierholzer\n    multi_adj = defaultdict(list)\n    for edge_key, count in edge_count.items():\n        a, b = edge_key\n        w = next(wt for x, y, wt in edges if tuple(sorted([x, y])) == edge_key)\n        for _ in range(count):\n            multi_adj[a].append(b)\n            multi_adj[b].append(a)\n    \n    # Hierholzer\'s algorithm for Eulerian circuit\n    route = []\n    stack = [0]\n    while stack:\n        v = stack[-1]\n        if multi_adj[v]:\n            u = multi_adj[v].pop()\n            multi_adj[u].remove(v)\n            stack.append(u)\n        else:\n            route.append(stack.pop())\n    \n    return route[::-1]\n'}