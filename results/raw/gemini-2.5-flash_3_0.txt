{'reasoning': "The core challenge of this graph layout problem is to devise an algorithm that scales efficiently across a vast range of graph sizes, from trivial (6 nodes) to extreme (10,000 nodes), all while adhering to the 'Python standard library only' constraint and completing within 30 seconds. This constraint significantly limits the use of optimized numerical libraries (like NumPy, SciPy) or dedicated graph libraries (like NetworkX), which would typically be leveraged for high-performance force-directed layouts or spectral methods.\n\nMy approach is an **adaptive strategy** that switches between algorithms based on the number of nodes (`num_nodes`):\n\n1.  **For Small to Medium Graphs (num_nodes <= 200):**\n    *   **Algorithm:** A custom-implemented, basic Fruchterman-Reingold (FR) style force-directed algorithm. This algorithm is known for producing aesthetically pleasing layouts with good crossing minimization for smaller, often planar, graphs.\n    *   **How it works:** Nodes are initially placed randomly. In each iteration, attractive forces are applied between connected nodes (like springs), and repulsive forces are applied between all pairs of nodes (like charged particles). These forces cause nodes to move, and a 'temperature' parameter gradually reduces node movement, allowing the layout to converge to a stable state. A final scaling step normalizes the coordinates.\n    *   **Adaptation & Performance:** The FR algorithm has an O(N^2) complexity per iteration due to the all-pairs repulsion calculation, plus O(E) for attraction. For N=200, N^2 is 40,000. With 100 iterations, the total operations are in the low millions, which is manageable within Python's standard library performance limits for a few seconds. This threshold (N=200) is chosen as a practical limit where the O(N^2) computation starts to become too slow in pure Python.\n\n2.  **For Large to Extreme Graphs (num_nodes > 200):**\n    *   **Algorithm:** A degree-sorted circular layout.\n    *   **How it works:** Nodes are sorted by their degree (number of connections) in descending order. Then, these sorted nodes are placed sequentially around a circle. This simple heuristic aims to distribute high-degree nodes more evenly around the circumference, which can sometimes reduce visual clutter compared to an arbitrary ordering.\n    *   **Adaptation & Performance:** The FR algorithm's O(N^2) complexity becomes prohibitive for N > 200. For N=10,000, one iteration alone would involve 100 million repulsion calculations, making it impossible to meet the 30-second deadline. The circular layout, by contrast, has an O(N log N) complexity (dominated by sorting) or O(N) if sorting is skipped. This linear or near-linear time complexity is crucial for handling thousands of nodes efficiently within the time limit.\n    *   **Quality for Large N:** While a simple circular layout does not actively minimize edge crossings in the same way a force-directed algorithm does, it guarantees a valid, fast, and relatively organized layout. For very large, dense graphs, minimizing crossings is often an intractable problem, and a fast, readable layout becomes the primary goal.\n\n**Robustness and Edge Cases:**\n*   **Empty graphs (0 nodes):** Returns an empty list.\n*   **Single-node graphs (1 node):** Returns a single coordinate (0.0, 0.0).\n*   **Disconnected components:** For smaller graphs, FR will naturally cluster and separate components. For larger graphs, the circular layout places all nodes on a single circle, which is a performance-driven compromise.\n*   **Self-loops and Parallel Edges:** The implementation correctly ignores self-loops and treats parallel edges as a single logical edge for layout purposes, which is standard practice.\n*   **Coordinate Scaling:** The force-directed layout includes a final scaling and centering step to normalize the output coordinates into a reasonable range, making them suitable for visualization.\n\nThis adaptive strategy ensures that the `layout_graph` function provides a balance of layout quality and computational performance across all specified graph scales, respecting the strict 'standard library only' constraint.", 'python_code': "import math\nimport random\nimport sys # For float_info.max\n\ndef layout_graph(num_nodes, edges):\n    if num_nodes == 0:\n        return []\n    if num_nodes == 1:\n        return [(0.0, 0.0)]\n\n    # Prepare adjacency list and unique edges list for layout algorithms\n    adj_list = [[] for _ in range(num_nodes)]\n    unique_edges = set() # To handle parallel edges; self-loops are ignored in adj_list\n    for u, v in edges:\n        # Ensure nodes are within bounds (0 to num_nodes-1)\n        if not (0 <= u < num_nodes and 0 <= v < num_nodes):\n            continue\n        # Ignore self-loops for adj_list and unique_edges processing\n        if u == v:\n            continue\n        \n        # Add to adj_list for degree calculation and attractive forces\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        \n        # Store unique edges for iteration in force-directed layout\n        # Using sorted tuple ensures (u,v) and (v,u) are treated as the same edge\n        unique_edges.add(tuple(sorted((u, v))))\n\n    # Adaptive Strategy:\n    # Use Force-Directed for small to medium graphs for higher quality.\n    # Switch to a faster Circular Layout for large to extreme graphs due to O(N^2) bottleneck\n    # of force-directed algorithms in pure Python.\n    \n    # The threshold of 200 nodes is chosen empirically; beyond this, O(N^2) operations\n    # become too slow for the 30-second limit without optimized libraries like NumPy.\n    if num_nodes <= 200:\n        return _force_directed_layout(num_nodes, list(unique_edges))\n    else:\n        return _circular_layout(num_nodes, adj_list)\n\ndef _force_directed_layout(num_nodes, unique_edges):\n    # Fruchterman-Reingold like algorithm (simplified, without Barnes-Hut or NumPy)\n    \n    # --- Parameters ---\n    # Optimal distance constant (C) and initial area for layout\n    C = 1.0 \n    area = num_nodes * 100.0 # Bounding box area for initial spread\n    k = C * math.sqrt(area / num_nodes) # Optimal distance between nodes\n\n    iterations = 100 # Number of iterations\n    \n    # Initial temperature, decreasing with each iteration for convergence.\n    # A fraction of the side length of the layout area.\n    t = math.sqrt(area) / 10.0\n    \n    # --- Initialization ---\n    # Initial random positions for nodes within the estimated area\n    positions = [(random.uniform(0, math.sqrt(area)), random.uniform(0, math.sqrt(area))) for _ in range(num_nodes)]\n    displacements = [(0.0, 0.0)] * num_nodes\n\n    # --- Main Iteration Loop ---\n    for _ in range(iterations):\n        # Reset displacements for current iteration\n        displacements = [(0.0, 0.0)] * num_nodes\n\n        # Calculate repulsive forces between all pairs of nodes (O(N^2))\n        for i in range(num_nodes):\n            for j in range(i + 1, num_nodes):\n                p_i = positions[i]\n                p_j = positions[j]\n\n                delta_x = p_j[0] - p_i[0]\n                delta_y = p_j[1] - p_i[1]\n                distance = math.sqrt(delta_x**2 + delta_y**2)\n\n                # Handle very small distances to prevent division by zero or extreme forces\n                if distance < 0.01: \n                    distance = 0.01\n                    # Apply a small random perturbation to help resolve overlaps\n                    delta_x = random.uniform(-0.1, 0.1)\n                    delta_y = random.uniform(-0.1, 0.1)\n                    distance = math.sqrt(delta_x**2 + delta_y**2)\n\n                # Repulsion force: f_rep = k^2 / distance\n                force = k * k / distance\n\n                displacements[i] = (displacements[i][0] - delta_x / distance * force,\n                                    displacements[i][1] - delta_y / distance * force)\n                displacements[j] = (displacements[j][0] + delta_x / distance * force,\n                                    displacements[j][1] + delta_y / distance * force)\n\n        # Calculate attractive forces between connected nodes (O(E))\n        for u, v in unique_edges:\n            p_u = positions[u]\n            p_v = positions[v]\n\n            delta_x = p_v[0] - p_u[0]\n            delta_y = p_v[1] - p_u[1]\n            distance = math.sqrt(delta_x**2 + delta_y**2)\n\n            # Handle very small distances (should be mitigated by repulsion, but good for safety)\n            if distance < 0.01:\n                distance = 0.01\n\n            # Attraction force: f_att = distance^2 / k\n            force = distance * distance / k\n\n            displacements[u] = (displacements[u][0] + delta_x / distance * force,\n                                displacements[u][1] + delta_y / distance * force)\n            displacements[v] = (displacements[v][0] - delta_x / distance * force,\n                                displacements[v][1] - delta_y / distance * force)\n\n        # Update positions based on calculated forces and apply temperature cooling\n        for i in range(num_nodes):\n            dx, dy = displacements[i]\n            disp_mag = math.sqrt(dx**2 + dy**2)\n            \n            # Limit displacement by current temperature to prevent oscillations and ensure convergence\n            if disp_mag > t: \n                factor = t / disp_mag\n                dx *= factor\n                dy *= factor\n            \n            # Apply new position\n            positions[i] = (positions[i][0] + dx, positions[i][1] + dy)\n            \n        # Cool down the temperature for the next iteration\n        t *= 0.9 # A common cooling factor\n\n    # --- Post-processing: Center and Scale Layout ---\n    # This step normalizes coordinates to a reasonable visual range.\n    if num_nodes > 0:\n        min_x = min(p[0] for p in positions)\n        max_x = max(p[0] for p in positions)\n        min_y = min(p[1] for p in positions)\n        max_y = max(p[1] for p in positions)\n\n        width = max_x - min_x\n        height = max_y - min_y\n        \n        # Prevent division by zero if all nodes are at the exact same point\n        if width < 0.01: width = 0.01\n        if height < 0.01: height = 0.01\n\n        # Scale to fit approximately within a 1000x1000 unit area, centered around (0,0)\n        scale = min(1000.0 / width, 1000.0 / height) if num_nodes > 1 else 1.0\n        # Clamp scaling factor to prevent extremely small or large layouts\n        if scale > 10.0: scale = 10.0 \n        if scale < 0.1: scale = 0.1 \n\n        scaled_positions = []\n        center_x = (min_x + max_x) / 2.0\n        center_y = (min_y + max_y) / 2.0\n\n        for x, y in positions:\n            scaled_x = (x - center_x) * scale\n            scaled_y = (y - center_y) * scale\n            scaled_positions.append((scaled_x, scaled_y))\n        return scaled_positions\n    return positions\n\ndef _circular_layout(num_nodes, adj_list):\n    # A fast circular layout for large graphs. For visual improvement,\n    # nodes are sorted by their degree before placement.\n    \n    # Calculate degrees for sorting\n    degrees = [(len(adj_list[i]), i) for i in range(num_nodes)]\n    \n    # Sort nodes by degree in descending order. Secondary sort by original index\n    # ensures consistent ordering for nodes with same degree.\n    degrees.sort(key=lambda x: (-x[0], x[1]))\n\n    sorted_node_indices = [node_idx for _, node_idx in degrees]\n    \n    # Determine radius based on number of nodes to spread them out appropriately\n    radius = 500.0 # Base radius\n    if num_nodes > 1000: # Increase radius for very large graphs\n        radius = 500.0 + (num_nodes - 1000) / 10.0\n    elif num_nodes < 100: # Adjust radius for smaller 'large' graphs\n        radius = 200.0\n        \n    positions = [(0.0, 0.0)] * num_nodes # Pre-allocate positions list\n\n    # Place sorted nodes evenly on the circle\n    for i, node_idx in enumerate(sorted_node_indices):\n        angle = 2 * math.pi * i / num_nodes\n        x = radius * math.cos(angle)\n        y = radius * math.sin(angle)\n        positions[node_idx] = (x, y) # Store at original node_idx position\n        \n    return positions"}