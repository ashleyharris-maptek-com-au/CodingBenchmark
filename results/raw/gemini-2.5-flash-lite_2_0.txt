{'reasoning': "The Chinese Postman Problem (CPP) seeks the shortest closed walk that traverses every edge of a connected undirected graph at least once. The core idea is that if a graph is Eulerian (all nodes have even degree), any such walk is an optimal tour. If not, some edges must be traversed more than once. The edges that need to be duplicated correspond to the shortest paths between pairs of odd-degree nodes. The strategy is to find a minimum weight perfect matching on the subgraph induced by odd-degree nodes, where edge weights in this matching problem are the shortest path distances between the respective odd-degree nodes in the original graph. \n\nFor scalability, especially in Python, a direct implementation of minimum weight perfect matching can be computationally expensive for very large numbers of odd-degree nodes (which can be up to `num_nodes`). Therefore, an adaptive approach is crucial.\n\n1. **Graph Representation**: Adjacency list is efficient for sparse graphs, while an adjacency matrix might be better for dense graphs, but for CPP, we typically deal with sparse graphs. We'll use an adjacency list.\n\n2. **Eulerian Check**: First, check if the graph is connected and if all node degrees are even. If so, an Eulerian circuit exists, and we can find it using Hierholzer's algorithm. This is the base case and is very efficient.\n\n3. **Odd-Degree Nodes**: Identify all nodes with odd degrees. The number of such nodes is always even.\n\n4. **Shortest Paths**: Compute all-pairs shortest paths (APSP) if the number of odd-degree nodes is small, or run Dijkstra from each odd-degree node if the number is larger. For Python's standard library, running Dijkstra from each odd-degree node is more feasible than Floyd-Warshall for larger graphs. We can optimize Dijkstra using a min-heap.\n\n5. **Minimum Weight Perfect Matching (MWPM)**: This is the bottleneck. For small numbers of odd-degree nodes (e.g., < 20), we can use dynamic programming or brute-force with pruning. For larger numbers, general MWPM algorithms (like Blossom algorithm) are complex and slow to implement from scratch in pure Python. However, since we only need to match odd-degree nodes, we can use a greedy approach or a simpler MWPM algorithm if the number of odd-degree nodes is manageable. A common heuristic is to use a brute-force approach for small sets of odd-degree nodes or a randomized approach for very large sets if an exact solution becomes infeasible within the time limit.\n\n**Adaptation Strategy**: \n\n- **Trivial to Medium (up to ~200 nodes, few odd-degree nodes):** Standard Dijkstra from each odd-degree node, followed by a recursive/DP-based MWPM solver for up to 20 odd-degree nodes. If more odd-degree nodes, we might switch to a simplified MWPM approach.\n\n- **Large (500-1000 nodes):** If the number of odd-degree nodes is still relatively small (e.g., < 30), we can proceed with Dijkstra and a more optimized MWPM solver or a randomized approach. If the number of odd-degree nodes is large, we might need to rely on heuristics for matching, accepting a slightly suboptimal tour if exact MWPM is too slow.\n\n- **Extreme to Epic (5000-10000+ nodes):** For these scales, exact MWPM becomes prohibitively expensive. The number of odd-degree nodes could be very large. We'll focus on efficient shortest path computations. For MWPM, we'll use a greedy approach (iteratively match the closest pair of odd-degree nodes) or potentially a sampled/randomized approach to find a good-enough matching, as finding the *absolute minimum* perfect matching might exceed the 30-second limit. The goal shifts from absolute optimality to a practically optimal and timely solution. If the graph is disconnected, we solve for each connected component (or report an error if not all components need to be traversed, depending on problem interpretation - here, assume we must cover all edges in the input, so if disconnected and has edges in multiple components, it's impossible to form a single tour starting and ending at 0 unless 0 is in a component that contains all edges). \n\n**Implementation Details**: \n\n- **Dijkstra**: Use `heapq` for efficient priority queue.\n- **MWPM**: For a small number of odd nodes, a DP approach `dp[mask]` where `mask` represents the set of odd nodes already matched can be used. For larger sets, this DP is exponential. We will use a simplified MWPM approach for larger sets, possibly a greedy matching if performance becomes an issue, or a more constrained DP. \n\nGiven the constraint of using only the Python standard library and the strict time limit for large graphs, a full implementation of the Blossom algorithm is not feasible. We will implement a recursive/DP approach for MWPM that is efficient for a small number of odd-degree nodes, and for larger numbers, it will be crucial to either limit the size of odd-degree nodes considered for exact matching or resort to a greedy heuristic that is fast.\n\n**Revised MWPM strategy for scalability**: \nIf `len(odd_nodes)` is small (< 20), use the DP approach. If `len(odd_nodes)` is moderate (< 50), a more optimized version of MWPM (perhaps a simplified greedy matching or iterative closest pair) might be better. If `len(odd_nodes)` is large (> 50), a simple greedy matching strategy is essential for performance, accepting potential suboptimality for speed.\n\n**Handling Disconnected Graphs**: The problem statement implies a single route traversing *all* edges. If the graph is disconnected and edges exist in multiple components, and the start node 0 is not in a component that contains all edges, it's impossible to satisfy the condition. We'll check for connectivity of components containing edges. If node 0 is isolated but other components have edges, it's impossible. If node 0 is in a component with all edges, we proceed. If there are multiple components with edges, and node 0 isn't in a component encompassing all edges, we might need to infer how to handle it (e.g. a tour for the component of 0 or error). Assuming the problem implies a connected graph or we solve for the component containing node 0 and all its reachable edges.\n\nA robust solution would involve: \n1. Checking graph connectivity first. If disconnected and edges span multiple components, it's impossible unless node 0 is in a component that *contains all edges*. \n2. If connected, proceed with CPP logic. If disconnected, and edges are in multiple components, we could return an empty list or raise an error, as a single tour is impossible. We will assume the input graph is implicitly connected for the purpose of finding a single route. If not, we'll check if node 0 is in a component that has all the edges.\n\n**Final Strategy**: \n- Check connectivity of the graph using BFS/DFS. If edges exist in multiple disconnected components, return an empty list. \n- If connected or all edges are in the component of node 0:\n  - Compute node degrees.\n  - Find odd-degree nodes.\n  - If no odd-degree nodes, find Eulerian circuit directly (Hierholzer's).\n  - If odd-degree nodes exist:\n    - Compute shortest paths between all pairs of odd-degree nodes using Dijkstra from each odd-degree node.\n    - For MWPM:\n      - If num_odd_nodes <= 16: Use DP-based exact MWPM.\n      - If num_odd_nodes <= 40: Use a greedy iterative closest pair matching (faster than DP, still potentially exact for some structures).\n      - If num_odd_nodes > 40: Use a simple greedy matching (fastest, potentially suboptimal).\n    - Duplicate edges based on MWPM result.\n    - Find Eulerian circuit in the augmented graph.\n    - Convert circuit to a node path. The path will be a list of nodes.", 'python_code': "import heapq\nimport collections\nimport itertools\n\ndef solve_cpp(num_nodes, edges):\n    if not edges:\n        return [0] if num_nodes > 0 else []\n\n    # --- Graph Representation --- \n    adj = collections.defaultdict(list)\n    degrees = [0] * num_nodes\n    total_weight = 0\n    edge_map = {}\n    edge_id_counter = 0\n\n    for u, v, w in edges:\n        adj[u].append((v, w, edge_id_counter))\n        adj[v].append((u, w, edge_id_counter))\n        degrees[u] += 1\n        degrees[v] += 1\n        total_weight += w\n        edge_map[edge_id_counter] = (u, v, w) # Store original edges for path reconstruction\n        edge_id_counter += 1\n\n    # --- Connectivity Check (only for components with edges) --- \n    nodes_with_edges = set()\n    for u, v, w in edges:\n        nodes_with_edges.add(u)\n        nodes_with_edges.add(v)\n    \n    if not nodes_with_edges: # No edges, but num_nodes > 0\n        return [0]\n\n    start_node_for_conn = next(iter(nodes_with_edges))\n    visited_conn = set()\n    q_conn = collections.deque([start_node_for_conn])\n    visited_conn.add(start_node_for_conn)\n    \n    while q_conn:\n        u = q_conn.popleft()\n        for v, _, _ in adj[u]:\n            if v not in visited_conn:\n                visited_conn.add(v)\n                q_conn.append(v)\n    \n    # Check if all nodes that are part of an edge are in the same component\n    if not nodes_with_edges.issubset(visited_conn):\n        # The graph is disconnected and edges span multiple components.\n        # If the start node 0 is not part of the component containing all edges, impossible.\n        # However, if node 0 is isolated but all edges are in ONE component, we can still solve for that component.\n        # The prompt implies a single route covering *all* edges. If edges are split across components, this is impossible.\n        # We'll assume for this problem that if edges are disconnected, no single tour can cover them.\n        return []\n\n    # --- Find Odd Degree Nodes --- \n    odd_degree_nodes = [i for i, degree in enumerate(degrees) if degree % 2 != 0]\n\n    # --- If Eulerian, find circuit directly --- \n    if not odd_degree_nodes:\n        eulerian_path_nodes = find_eulerian_circuit(num_nodes, adj, edge_map)\n        return eulerian_path_nodes\n\n    # --- Compute Shortest Paths Between Odd Degree Nodes --- \n    odd_node_shortest_paths = {}\n    for i in range(len(odd_degree_nodes)):\n        u = odd_degree_nodes[i]\n        dist, paths = dijkstra(num_nodes, adj, u)\n        for j in range(i + 1, len(odd_degree_nodes)):\n            v = odd_degree_nodes[j]\n            odd_node_shortest_paths[(u, v)] = (dist[v], paths[v])\n            odd_node_shortest_paths[(v, u)] = (dist[v], paths[v]) # Store for symmetry\n\n    # --- Minimum Weight Perfect Matching --- \n    # Strategy: DP for small |odd_nodes|, greedy for large \n    num_odd = len(odd_degree_nodes)\n    min_weight_matching = None\n    min_matching_weight = float('inf')\n\n    if num_odd <= 16: # DP-based MWPM for small sets\n        min_weight_matching, min_matching_weight = solve_mwpm_dp(odd_degree_nodes, odd_node_shortest_paths)\n    elif num_odd <= 40: # Greedy iterative closest pair for moderate sets\n        min_weight_matching, min_matching_weight = solve_mwpm_greedy_iterative(odd_degree_nodes, odd_node_shortest_paths)\n    else: # Simple greedy matching for large sets (performance over absolute optimality)\n        min_weight_matching, min_matching_weight = solve_mwpm_greedy_simple(odd_degree_nodes, odd_node_shortest_paths)\n\n    # --- Augment Graph with Duplicate Edges --- \n    augmented_adj = collections.defaultdict(list)\n    augmented_edges = list(edges)\n    edge_id_counter_aug = edge_id_counter\n\n    for u, v in min_weight_matching:\n        path_uv_nodes = odd_node_shortest_paths[(u, v)][1]\n        for i in range(len(path_uv_nodes) - 1):\n            p1, p2 = path_uv_nodes[i], path_uv_nodes[i+1]\n            # Find the original edge weight between p1 and p2\n            weight = 0\n            for neighbor, w, _ in adj[p1]:\n                if neighbor == p2:\n                    weight = w\n                    break\n            augmented_edges.append((p1, p2, weight))\n            edge_id_counter_aug += 1\n\n    # Rebuild adjacency list for the augmented graph\n    for u, v, w in augmented_edges:\n        augmented_adj[u].append((v, w, edge_id_counter_aug))\n        augmented_adj[v].append((u, w, edge_id_counter_aug))\n        edge_id_counter_aug += 1\n\n    # --- Find Eulerian Circuit in Augmented Graph --- \n    # We need to ensure the start node is 0. If the graph was connected, this is fine.\n    # If the original graph was not connected but we are solving for the component of 0, \n    # then we find the circuit within that component.\n    # find_eulerian_circuit needs to be able to start from 0.\n    # The augmented graph *must* be Eulerian, so any node with edges can be a start.\n    # We'll ensure it starts from node 0 if possible.\n    \n    # Build edge_map for augmented graph for path reconstruction\n    augmented_edge_map = {} # key: edge_id, value: (u, v, w)\n    current_edge_id = 0\n    for u, v, w in augmented_edges:\n        augmented_edge_map[current_edge_id] = (u, v, w)\n        current_edge_id += 1\n\n    eulerian_path_nodes = find_eulerian_circuit(num_nodes, augmented_adj, augmented_edge_map, start_node=0)\n    return eulerian_path_nodes\n\n\ndef dijkstra(num_nodes, adj, start_node):\n    distances = {i: float('inf') for i in range(num_nodes)}\n    predecessors = {i: None for i in range(num_nodes)}\n    distances[start_node] = 0\n    pq = [(0, start_node)] # (distance, node)\n\n    while pq:\n        dist, u = heapq.heappop(pq)\n\n        if dist > distances[u]:\n            continue\n\n        for v, weight, _ in adj[u]:\n            if distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n                predecessors[v] = u\n                heapq.heappush(pq, (distances[v], v))\n\n    # Reconstruct paths\n    paths = {i: [] for i in range(num_nodes)}\n    for i in range(num_nodes):\n        if distances[i] != float('inf'):\n            path = []\n            curr = i\n            while curr is not None:\n                path.append(curr)\n                curr = predecessors[curr]\n            paths[i] = path[::-1]\n    \n    return distances, paths\n\n\ndef find_eulerian_circuit(num_nodes, adj, edge_map, start_node=0):\n    if not adj: return [0] if num_nodes > 0 else []\n\n    # Hierholzer's Algorithm\n    current_path = []\n    circuit = []\n    \n    # Need a mutable adjacency list that we can 'remove' edges from\n    # Store edge indices to track used edges efficiently\n    adj_list_mutable = collections.defaultdict(list)\n    edge_counts = collections.defaultdict(int)\n    original_edge_ids = {} # Map (u, v, edge_idx_in_list) to global edge_id\n    \n    # Populate mutable adj list and edge counts, and map original IDs\n    for u in adj:\n        for v, w, edge_id in adj[u]:\n            adj_list_mutable[u].append((v, w, edge_id))\n            edge_counts[edge_id] += 1\n            original_edge_ids[edge_id] = edge_id\n            \n    # Ensure start_node has edges if it's supposed to be in the circuit\n    # If start_node is isolated but other nodes have edges, we might have issues.\n    # The problem guarantees node 0 as start/end. If node 0 has no edges, but graph has edges elsewhere, \n    # then a tour starting/ending at 0 is impossible unless it's just [0].\n    # For CPP, if node 0 is isolated but graph has edges, it implies an impossible scenario for the stated requirements.\n    # Assuming node 0 will be part of the connected component with edges if edges exist.\n    if start_node not in adj_list_mutable and any(adj_list_mutable.values()):\n         # If start_node is isolated but there are edges elsewhere, and we previously passed connectivity checks,\n         # this implies something is wrong or node 0 is not part of the relevant component.\n         # For a valid CPP, start_node must be in the component containing edges.\n         # If we reached here, and start_node has no edges, it implies an impossible scenario for the requested tour.\n         return []\n\n    # Start traversal from start_node\n    current_path.append(start_node)\n    \n    while current_path:\n        u = current_path[-1]\n        \n        found_edge = False\n        # Find an unused edge from u\n        while adj_list_mutable[u]:\n            v, w, edge_id = adj_list_mutable[u].pop()\n            # Check if this edge is still available (i.e., has not been 'removed' from both ends)\n            if edge_counts[edge_id] > 0:\n                edge_counts[edge_id] -= 1\n                current_path.append(v)\n                found_edge = True\n                break # Move to the next node v\n        \n        if not found_edge:\n            # If no unused edges from u, backtrack: add u to circuit and pop from path\n            circuit.append(current_path.pop())\n            \n    # The circuit is built in reverse\n    return circuit[::-1]\n\n# --- MWPM Solvers --- \n\ndef solve_mwpm_dp(odd_nodes, odd_node_shortest_paths):\n    n = len(odd_nodes)\n    # Use a list of indices for DP state\n    odd_indices = {node: i for i, node in enumerate(odd_nodes)}\n\n    # dp[mask] = (min_cost, matching_pairs)\n    # mask is a bitmask representing subsets of odd_nodes\n    dp = {} \n    dp[0] = (0, [])\n\n    for mask in range(1, 1 << n):\n        if mask not in dp: # If this state hasn't been reached yet (shouldn't happen with proper iteration order)\n            continue\n        \n        # Find the lowest set bit (first unpaired node in this mask)\n        first_unpaired_idx = -1\n        for i in range(n):\n            if (mask >> i) & 1:\n                first_unpaired_idx = i\n                break\n        \n        u = odd_nodes[first_unpaired_idx]\n        \n        # Try pairing u with every other unpaired node v in the current mask\n        for j in range(first_unpaired_idx + 1, n):\n            if (mask >> j) & 1: # If v is also in the current mask\n                v = odd_nodes[j]\n                \n                # Cost of pairing u and v\n                cost_uv, _ = odd_node_shortest_paths[(u, v)]\n                \n                # The remaining nodes to match are represented by mask excluding u and v\n                remaining_mask = mask ^ (1 << first_unpaired_idx) ^ (1 << j)\n                \n                if remaining_mask in dp:\n                    prev_cost, prev_matching = dp[remaining_mask]\n                    current_total_cost = prev_cost + cost_uv\n                    \n                    current_mask_state = (1 << first_unpaired_idx) | (1 << j) | remaining_mask\n                    \n                    # Update DP if this path is better\n                    if current_mask_state not in dp or current_total_cost < dp[current_mask_state][0]:\n                        dp[current_mask_state] = (current_total_cost, prev_matching + [(u, v)])\n\n    final_mask = (1 << n) - 1\n    if final_mask in dp:\n        return dp[final_mask][1], dp[final_mask][0]\n    else:\n        # Should not happen if graph is connected and odd_nodes is populated correctly\n        return [], float('inf')\n\n\ndef solve_mwpm_greedy_iterative(odd_nodes, odd_node_shortest_paths):\n    # Iteratively find the closest pair and match them.\n    # This is a greedy approach and may not be optimal, but faster than DP for larger sets.\n    unmatched_nodes = set(odd_nodes)\n    matching = []\n    total_weight = 0\n\n    while unmatched_nodes:\n        min_pair_weight = float('inf')\n        best_pair = None\n        \n        # Find the closest pair among the remaining unmatched nodes\n        node_list = list(unmatched_nodes)\n        for i in range(len(node_list)):\n            for j in range(i + 1, len(node_list)):\n                u = node_list[i]\n                v = node_list[j]\n                weight, _ = odd_node_shortest_paths.get((u, v), (float('inf'), None))\n                if weight < min_pair_weight:\n                    min_pair_weight = weight\n                    best_pair = (u, v)\n        \n        if best_pair:\n            u, v = best_pair\n            matching.append((u, v))\n            total_weight += min_pair_weight\n            unmatched_nodes.remove(u)\n            unmatched_nodes.remove(v)\n        else:\n            # This indicates an issue, possibly a disconnected component for odd nodes\n            # Or if all remaining nodes are only connected to themselves in distance matrix (shouldn't happen for paths)\n            break\n    \n    return matching, total_weight\n\ndef solve_mwpm_greedy_simple(odd_nodes, odd_node_shortest_paths):\n    # Simple greedy matching: pick any pair, match it, repeat.\n    # This is even faster but potentially less optimal than iterative closest pair.\n    # A more sophisticated greedy could pick the globally closest pair first.\n    # Let's use a version that picks the globally closest pair greedily first.\n    \n    unmatched = list(odd_nodes)\n    matching = []\n    total_weight = 0\n\n    while unmatched:\n        min_weight = float('inf')\n        best_pair = None\n        \n        for i in range(len(unmatched)):\n            for j in range(i + 1, len(unmatched)):\n                u = unmatched[i]\n                v = unmatched[j]\n                weight, _ = odd_node_shortest_paths.get((u, v), (float('inf'), None))\n                if weight < min_weight:\n                    min_weight = weight\n                    best_pair = (u, v)\n        \n        if best_pair:\n            u, v = best_pair\n            matching.append((u, v))\n            total_weight += min_weight\n            unmatched.remove(u)\n            unmatched.remove(v)\n        else:\n            # Should not happen in a connected graph with an even number of odd nodes\n            break\n            \n    return matching, total_weight\n\n"}