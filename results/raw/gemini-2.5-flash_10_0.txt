{'reasoning': "The 2D Cutting Stock Problem, also known as Rectangle Bin Packing, is an NP-hard optimization problem. For small (trivial) instances, exact methods like Mixed Integer Linear Programming (MILP) can find optimal solutions. However, for large (ludicrous) instances (thousands of rectangles on large boards), MILP is computationally intractable within a reasonable time frame. Therefore, a heuristic approach is necessary, and the challenge lies in creating a single function that performs well across all scales.\n\nMy algorithm adopts a well-known and efficient heuristic called **First Fit Decreasing Area (FFDA) combined with a MaxRects-like approach for managing free space on each individual board.** This strategy offers a good balance between solution quality and computational performance, making it suitable for varying problem sizes.\n\nHere's a breakdown of the algorithm and its adaptability:\n\n1.  **Rectangle Preprocessing and Sorting (FFDA Principle):**\n    *   Each rectangle `(width, height)` is considered in two possible orientations: `(width, height)` and `(height, width)` (if `width != height`). Each option retains its original index and a `rotated` flag.\n    *   These rectangle options are then sorted by a heuristic: primarily by **decreasing area** (`width * height`), then by **decreasing longest side**, and finally by **decreasing shortest side**. Placing larger items first (FFDA) generally reduces fragmentation and leads to better packing density.\n    *   This sorting step has a complexity of `O(N log N)` where `N` is the number of original rectangles, which is efficient for all scales.\n\n2.  **Board Management (First Fit):**\n    *   The algorithm maintains a list of `BoardPacker` instances, each representing a single wholesale board.\n    *   When trying to place a rectangle, it iterates through the existing boards (First Fit). If a suitable space is found on an existing board, the rectangle is placed there. If no space is found on any existing board, a new `BoardPacker` instance (a new board) is created.\n    *   This part introduces a factor of `M` (number of boards used) into the complexity, where `M` can be up to `N` in the worst case.\n\n3.  **Space Management on a Single Board (MaxRects Heuristic):**\n    *   Each `BoardPacker` instance uses a MaxRects-like approach to manage the available (free) space on its board.\n    *   It maintains two lists: `placed_rects` (rectangles already occupying space) and `free_rects` (empty rectangular regions where new items can be placed). Initially, `free_rects` contains a single rectangle representing the entire board.\n    *   **Finding the Best Fit (`find_best_fit`):** To place a new rectangle, the `BoardPacker` iterates through its `free_rects` list. For each free space, it considers both orientations of the new rectangle and calculates a score. The heuristic used is **'Best Short Side Fit'** (minimizing the shorter of the two leftover sides after placement), with a **'Bottom-Left'** rule for tie-breaking (preferring lower-left positions). This step has a complexity of `O(N_free)` where `N_free` is the current number of free rectangles on that board.\n    *   **Placing a Rectangle and Updating Free Space (`place_rectangle`):**\n        *   When a rectangle is placed in a chosen `free_rect`, that `free_rect` is removed.\n        *   The placed rectangle 'cuts' the original `free_rect` into up to four new, smaller `free_rect`s. These new free rectangles are added to the `free_rects` list.\n        *   **Pruning (`_prune_free_rects`):** After adding new free rectangles, the list is pruned to remove redundant entries. Specifically, any `free_rect` that is fully contained within another `free_rect` is removed. Also, any `free_rect` that ends up fully contained by the newly placed rectangle is removed. This pruning step ensures the `free_rects` list remains clean and prevents redundant search spaces. In its naive implementation, this step has a worst-case complexity of `O(N_free^2)`.\n\n**Scalability and Performance:**\n\n*   **Trivial Scale (4-8 rectangles):** For small problems, the algorithm's overhead (sorting, list manipulations) is minimal. The `O(N_free^2)` pruning step on individual boards will be very fast as `N_free` will be tiny. It will provide near-optimal or optimal solutions quickly.\n*   **Ludicrous Scale (500-5000 rectangles):** This is where the heuristics shine. While the theoretical worst-case complexity for a MaxRects-based approach can be high (`O(N^4)` if `N_free` grows to `O(N)` for `M` boards), in practice, the number of free rectangles (`N_free`) on a single board typically remains much smaller than the total number of items `N` and is often bounded by the perimeter of the placed items. For many real-world scenarios, `N_free` is a manageable size, making the `O(N_free^2)` pruning efficient enough. The `N log N` sorting and `M * N_free` search operations dominate, leading to a practical average-case performance closer to `O(N^2)` or `O(N^2 log N)`, which is feasible within 30 seconds for 5000 rectangles.\n\n**Key Optimizations for Performance:**\n\n*   **Efficient Rectangle Representation:** Using tuples `(x, y, w, h)` for rectangles throughout instead of objects minimizes memory overhead and allows faster comparisons.\n*   **List-based Operations:** Python's built-in list operations are highly optimized in C, providing good performance for managing `placed_rects` and `free_rects` lists.\n*   **Greedy Heuristics:** FFDA and MaxRects are greedy, making local optimal choices without exhaustive search, ensuring fast execution.\n*   **Early Exit:** Once a rectangle is placed in one of its orientations, other orientations for the same original rectangle are skipped, preventing redundant work.\n\nThis combination of strategies allows the single `solve_2d_cutting` function to handle the specified range of problem sizes effectively, balancing solution quality with the strict performance requirements.", 'python_code': 'import collections\n\n# Helper function to check for overlap between two rectangles (x1, y1, w1, h1) and (x2, y2, w2, h2)\ndef overlaps(r1, r2):\n    return not (r1[0] + r1[2] <= r2[0] or \n                r1[0] >= r2[0] + r2[2] or \n                r1[1] + r1[3] <= r2[1] or \n                r1[1] >= r2[1] + r2[3])\n\n# Helper function to check if r1 is fully contained within r2\ndef contains(r1, r2):\n    return r1[0] >= r2[0] and \\\n           r1[1] >= r2[1] and \\\n           r1[0] + r1[2] <= r2[0] + r2[2] and \\\n           r1[1] + r1[3] <= r2[1] + r2[3]\n\nclass BoardPacker:\n    """\n    Implements a MaxRects-like bin packing algorithm for a single board.\n    Maintains a list of placed rectangles and a list of free (empty) rectangles.\n    When a new rectangle is placed, it splits the free rectangle it occupies and prunes\n    redundant free rectangles.\n    """\n    def __init__(self, board_width, board_height):\n        self.board_width = board_width\n        self.board_height = board_height\n        self.placed_rects = [] # List of (x, y, w, h)\n        # Initially, the entire board is one free rectangle\n        self.free_rects = [(0, 0, board_width, board_height)] # List of (x, y, w, h)\n\n    def find_best_fit(self, rect_w, rect_h):\n        """\n        Finds the best free space to place a rectangle (rect_w, rect_h).\n        Uses a \'Best Short Side Fit\' heuristic combined with \'Bottom-Left\' for tie-breaking.\n        Returns: ((x, y, actual_w, actual_h, rotated_flag), best_free_idx) or (None, -1)\n        """\n        best_fit_placement = None\n        best_free_idx = -1\n        # Score based on \'Best Short Side Fit\': minimize the shorter leftover side\n        # Followed by \'Bottom-Left\' for tie-breaking (smaller y, then smaller x)\n        best_score_tuple = (float(\'inf\'), float(\'inf\'), float(\'inf\')) \n\n        for i, free_rect in enumerate(self.free_rects):\n            fx, fy, fw, fh = free_rect\n\n            # Try original orientation\n            if rect_w <= fw and rect_h <= fh:\n                short_side_fit = min(fw - rect_w, fh - rect_h)\n                current_score_tuple = (short_side_fit, fy, fx) # Prefer lower-left\n                if current_score_tuple < best_score_tuple:\n                    best_score_tuple = current_score_tuple\n                    best_fit_placement = (fx, fy, rect_w, rect_h, False)\n                    best_free_idx = i\n            \n            # Try rotated orientation (if dimensions are different and it fits)\n            if rect_w != rect_h and rect_h <= fw and rect_w <= fh:\n                short_side_fit = min(fw - rect_h, fh - rect_w)\n                current_score_tuple = (short_side_fit, fy, fx)\n                if current_score_tuple < best_score_tuple:\n                    best_score_tuple = current_score_tuple\n                    best_fit_placement = (fx, fy, rect_h, rect_w, True) # Use rotated dimensions\n                    best_free_idx = i\n\n        return best_fit_placement, best_free_idx\n\n    def place_rectangle(self, placement_tuple, free_idx_to_remove):\n        """\n        Places a rectangle at the given position and updates the free space list.\n        Args:\n            placement_tuple: (x, y, w, h, rotated_flag)\n            free_idx_to_remove: The index of the free rectangle that was used for placement.\n        """\n        x, y, w, h, _ = placement_tuple\n        placed_rect = (x, y, w, h)\n        self.placed_rects.append(placed_rect)\n\n        # Remove the free rectangle that was used for placement\n        original_free_rect = self.free_rects.pop(free_idx_to_remove)\n        \n        # Generate new free rectangles by splitting the original_free_rect\n        # by the newly placed_rect. This creates up to 4 new potential free rectangles.\n        newly_generated_free_rects = []\n        \n        # 1. Part below the placed rect\n        if y > original_free_rect[1]:\n            newly_generated_free_rects.append((original_free_rect[0], original_free_rect[1], original_free_rect[2], y - original_free_rect[1]))\n        \n        # 2. Part above the placed rect\n        if y + h < original_free_rect[1] + original_free_rect[3]:\n            newly_generated_free_rects.append((original_free_rect[0], y + h, original_free_rect[2], (original_free_rect[1] + original_free_rect[3]) - (y + h)))\n        \n        # 3. Part left of the placed rect (intersecting vertically with the placed rect\'s Y span)\n        if x > original_free_rect[0]:\n            newly_generated_free_rects.append((original_free_rect[0], max(original_free_rect[1], y), x - original_free_rect[0], min(original_free_rect[1] + original_free_rect[3], y + h) - max(original_free_rect[1], y)))\n        \n        # 4. Part right of the placed rect (intersecting vertically with the placed rect\'s Y span)\n        if x + w < original_free_rect[0] + original_free_rect[2]:\n            newly_generated_free_rects.append((x + w, max(original_free_rect[1], y), (original_free_rect[0] + original_free_rect[2]) - (x + w), min(original_free_rect[1] + original_free_rect[3], y + h) - max(original_free_rect[1], y)))\n\n        # Add only valid, non-zero area free rectangles to the list\n        for new_f_rect in newly_generated_free_rects:\n            if new_f_rect[2] > 0 and new_f_rect[3] > 0:\n                self.free_rects.append(new_f_rect)\n\n        # Prune redundant free rectangles: remove any free_rect that is fully contained\n        # within another free_rect or fully covered by the newly placed_rect.\n        self._prune_free_rects(placed_rect)\n\n    def _prune_free_rects(self, new_placed_rect):\n        """\n        Removes free rectangles that are redundant (e.g., fully contained by another free rect).\n        Also removes free rectangles that are now fully covered by the newly placed rectangle.\n        """\n        # Filter out free_rects that are fully contained by the new_placed_rect\n        self.free_rects = [f_rect for f_rect in self.free_rects if not contains(f_rect, new_placed_rect)]\n\n        # Efficiently prune free_rects that are contained by other free_rects\n        num_free = len(self.free_rects)\n        if num_free < 2:\n            return # No need to prune if less than 2 free rectangles\n\n        # Create a boolean array to mark free_rects that should be removed\n        to_remove = [False] * num_free\n\n        for i in range(num_free):\n            if to_remove[i]: \n                continue # Skip if already marked for removal\n\n            r1 = self.free_rects[i]\n            for j in range(num_free):\n                if i == j: \n                    continue\n                r2 = self.free_rects[j]\n\n                # If r1 is contained within r2, mark r1 for removal\n                if contains(r1, r2):\n                    to_remove[i] = True\n                    break\n        \n        # Build the new list of free rectangles, excluding those marked for removal\n        cleaned_free_rects = []\n        for i in range(num_free):\n            if not to_remove[i]:\n                cleaned_free_rects.append(self.free_rects[i])\n        \n        self.free_rects = cleaned_free_rects\n\ndef solve_2d_cutting(rectangles, board_width, board_height):\n    """\n    Solves the 2D Cutting Stock Problem using a First Fit Decreasing Area\n    strategy combined with the MaxRects heuristic for individual board packing.\n\n    Args:\n        rectangles: List of (width, height) tuples for pieces to cut.\n        board_width, board_height: Dimensions of wholesale boards.\n\n    Returns:\n        A dictionary with \'num_boards\' and \'placements\' (list of dicts).\n    """\n    # 1. Preprocess rectangles: Generate all possible orientations and store original indices.\n    # We\'ll use (original_idx, current_w, current_h, is_rotated)\n    rect_options = []\n    for i, (w, h) in enumerate(rectangles):\n        # Original orientation\n        rect_options.append((i, w, h, False))\n        # Rotated orientation (if not square)\n        if w != h:\n            rect_options.append((i, h, w, True))\n    \n    # 2. Sort rectangles: First Fit Decreasing Area heuristic.\n    # Prioritize by decreasing area, then by decreasing longest side, then by decreasing shortest side.\n    rect_options.sort(key=lambda x: (x[1] * x[2], max(x[1], x[2]), min(x[1], x[2])), reverse=True)\n\n    # Stores the final placements for each original rectangle index\n    placements_by_original_idx = [None] * len(rectangles)\n    \n    # List of BoardPacker instances (representing individual boards)\n    boards = [] \n\n    # 3. Main packing loop\n    for original_idx, current_w, current_h, is_rotated in rect_options:\n        # If this rectangle has already been placed in an optimal orientation, skip it.\n        # This ensures we only place each original rectangle once, with its best orientation.\n        if placements_by_original_idx[original_idx] is not None:\n            continue\n\n        best_board_idx = -1\n        best_placement_on_board = None # (x, y, actual_w, actual_h, rotated_flag)\n        best_free_idx_on_board = -1\n        \n        # Score (short_side_fit, y_coord, x_coord) - smaller is better\n        # This is used for comparison across different boards.\n        overall_best_board_score = (float(\'inf\'), float(\'inf\'), float(\'inf\'))\n\n        # Try to place the rectangle in an existing board\n        for b_idx, board_packer in enumerate(boards):\n            placement_attempt, free_idx_attempt = board_packer.find_best_fit(current_w, current_h)\n            if placement_attempt:\n                # Re-calculate the actual score for this placement for inter-board comparison.\n                # Using (short_side_fit, y, x) directly from find_best_fit logic.\n                # The x,y come from placement_attempt[0], placement_attempt[1].\n                # The actual short_side_fit needs to be recalculated or exposed by find_best_fit.\n                # For simplicity and consistency, let\'s use the placement\'s (y,x) for inter-board comparison (FFDH-like).\n                \n                # For inter-board comparison, prioritize boards where it can be placed lower and further left.\n                current_board_comparison_score = (placement_attempt[1], placement_attempt[0]) # (y, x)\n                \n                if current_board_comparison_score < (overall_best_board_score[1], overall_best_board_score[2]):\n                    overall_best_board_score = (current_board_comparison_score[0], current_board_comparison_score[0], current_board_comparison_score[1]) #dummy short_side_fit, y, x\n                    best_board_idx = b_idx\n                    best_placement_on_board = placement_attempt\n                    best_free_idx_on_board = free_idx_attempt\n\n        # If a suitable spot was found on an existing board\n        if best_board_idx != -1:\n            boards[best_board_idx].place_rectangle(best_placement_on_board, best_free_idx_on_board)\n            px, py, pw, ph, rotated = best_placement_on_board\n            placements_by_original_idx[original_idx] = (best_board_idx, px, py, rotated)\n        else:\n            # No space found in existing boards, create a new board\n            new_board_idx = len(boards)\n            new_board_packer = BoardPacker(board_width, board_height)\n            boards.append(new_board_packer) # Add board to list before placing\n\n            # For a new, empty board, the first placement will always be at (0,0).\n            # MaxRects\' find_best_fit should correctly identify (0,0) as the best fit\n            # and determine the best rotation if applicable.\n            placement_on_new_board, free_idx_on_new_board = new_board_packer.find_best_fit(current_w, current_h)\n            \n            if not placement_on_new_board: # Should not happen if rectangle fits board dimensions\n                # This implies the rectangle (even rotated) cannot fit on an empty board.\n                # Based on problem statement, assuming all rectangles fit on board_width x board_height.\n                raise ValueError(f"Rectangle {current_w}x{current_h} too large for board {board_width}x{board_height}")\n            \n            new_board_packer.place_rectangle(placement_on_new_board, free_idx_on_new_board)\n            \n            px, py, pw, ph, rotated = placement_on_new_board\n            placements_by_original_idx[original_idx] = (new_board_idx, px, py, rotated)\n\n    # 4. Format the output as required\n    final_placements = []\n    for original_idx in range(len(rectangles)): # Iterate by original_idx to maintain order if desired\n        placement = placements_by_original_idx[original_idx]\n        if placement is None:\n            # This case should ideally not be reached if all rectangles fit and are placed.\n            # For robustness, add a default/error handling, or assume problem guarantees fit.\n            # For example, skip if a rectangle somehow couldn\'t be placed.\n            continue \n        board_idx, x, y, rotated = placement\n        final_placements.append({"board_index": board_idx, "x": x, "y": y, "rotated": rotated})\n\n    return {\n        "num_boards": len(boards),\n        "placements": final_placements\n    }\n'}