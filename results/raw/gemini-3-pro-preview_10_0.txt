{'reasoning': "For the 2D Cutting Stock Problem scaling from trivial to 5000+ rectangles, I selected the 'Guillotine Packing' algorithm with a 'Best Short Side Fit' (BSSF) heuristic. \n\n1. **Scalability**: Unlike Maximal Rectangles (MaxRects) which can suffer from O(N^3) complexity due to fragmented free space, Guillotine packing maintains disjoint free rectangles, ensuring O(N^2) complexity. This guarantees the solution runs within 30 seconds even for 5000 items.\n\n2. **Quality vs. Speed**: To minimize the number of boards, I employ a 'First Fit Decreasing' strategy at the board level (filling the first available board before opening a new one) combined with 'Best Short Side Fit' within the board. BSSF minimizes the wasted length on the shorter side of the free rectangle, producing tight packings. \n\n3. **Split Heuristic**: When a rectangle is placed, the remaining L-shaped free space is split to maximize the area of the single largest remaining free rectangle. This reduces fragmentation and leaves large usable spaces for subsequent items.", 'python_code': 'def solve_2d_cutting(rectangles, board_width, board_height):\n    """\n    Solves 2D Cutting Stock Problem using Guillotine Packing with Best Short Side Fit (BSSF).\n    Complexity: O(N^2) - suitable for up to 5000 items within 30s.\n    """\n    # Prepare items with metadata: (width, height, original_index, area)\n    items = []\n    for i, (w, h) in enumerate(rectangles):\n        items.append({\'w\': w, \'h\': h, \'id\': i, \'area\': w * h})\n\n    # Sort items by Area Descending (heuristic for packing density)\n    items.sort(key=lambda x: x[\'area\'], reverse=True)\n\n    # Boards list. Each board is a list of free rectangles [(x, y, w, h)]\n    boards = []\n    placements = [None] * len(rectangles)\n\n    for item in items:\n        item_w, item_h = item[\'w\'], item[\'h\']\n        placed = False\n        \n        # Variables to track the best fit across the current board being checked\n        best_board_idx = -1\n        best_rect_idx = -1\n        best_placement = None\n        best_rotated = False\n        \n        # Strategy: First Fit Board, Best Fit Rect.\n        # Try to pack into the first board that accommodates the item to minimize board usage.\n        for b_idx, free_rects in enumerate(boards):\n            best_score = float(\'inf\')\n            found_in_board = False\n            \n            # Search for best fit within this board\n            for r_idx, (fx, fy, fw, fh) in enumerate(free_rects):\n                # Check Normal Orientation\n                if fw >= item_w and fh >= item_h:\n                    # BSSF: Minimize the unused length of the shorter remaining side\n                    score = min(fw - item_w, fh - item_h)\n                    if score < best_score:\n                        best_score = score\n                        best_rect_idx = r_idx\n                        best_rotated = False\n                        best_placement = (fx, fy, item_w, item_h)\n                        found_in_board = True\n                        if score == 0: break # Perfect fit\n                \n                # Check Rotated Orientation\n                if item_w != item_h and fw >= item_h and fh >= item_w:\n                    score = min(fw - item_h, fh - item_w)\n                    if score < best_score:\n                        best_score = score\n                        best_rect_idx = r_idx\n                        best_rotated = True\n                        best_placement = (fx, fy, item_h, item_w)\n                        found_in_board = True\n                        if score == 0: break\n            \n            # If we found a valid spot in this board, use it immediately (First Fit Board)\n            if found_in_board:\n                best_board_idx = b_idx\n                placed = True\n                break\n        \n        if placed:\n            # Apply placement\n            free_rects = boards[best_board_idx]\n            fx, fy, fw, fh = free_rects.pop(best_rect_idx)\n            px, py, pw, ph = best_placement\n            \n            placements[item[\'id\']] = (best_board_idx, px, py, best_rotated)\n            \n            # Guillotine Split: Split the remaining L-shape into two disjoint rectangles\n            # Heuristic: Maximize the area of the larger resulting rectangle (keep big chunks)\n            \n            # Option 1: Vertical Cut (Split width)\n            # Top piece: (fx, fy + ph, pw, fh - ph)\n            # Right piece: (fx + pw, fy, fw - pw, fh) -> Keeps full height\n            \n            # Option 2: Horizontal Cut (Split height)\n            # Top piece: (fx, fy + ph, fw, fh - ph) -> Keeps full width\n            # Right piece: (fx + pw, fy, fw - pw, ph)\n            \n            # Compare area of the larger chunks: (fw-pw)*fh vs fw*(fh-ph)\n            new_rects = []\n            if (fw - pw) * fh > fw * (fh - ph):\n                # Vertical Cut preferred\n                r1 = (fx + pw, fy, fw - pw, fh)\n                r2 = (fx, fy + ph, pw, fh - ph)\n            else:\n                # Horizontal Cut preferred\n                r1 = (fx + pw, fy, fw - pw, ph)\n                r2 = (fx, fy + ph, fw, fh - ph)\n            \n            if r1[2] > 0 and r1[3] > 0: new_rects.append(r1)\n            if r2[2] > 0 and r2[3] > 0: new_rects.append(r2)\n            \n            free_rects.extend(new_rects)\n            \n        else:\n            # Create new board\n            b_idx = len(boards)\n            \n            # Determine orientation for new board (0,0)\n            pw, ph = item_w, item_h\n            rotated = False\n            if pw > board_width or ph > board_height:\n                pw, ph = item_h, item_w\n                rotated = True\n                # Note: Assumes item fits rotated. If not, input violates constraints.\n            \n            placements[item[\'id\']] = (b_idx, 0, 0, rotated)\n            \n            # Split the initial board free space\n            new_rects = []\n            # Initial Board: (0, 0, board_width, board_height)\n            # Used: (0, 0, pw, ph)\n            \n            if (board_width - pw) * board_height > board_width * (board_height - ph):\n                 r1 = (pw, 0, board_width - pw, board_height)\n                 r2 = (0, ph, pw, board_height - ph)\n            else:\n                 r1 = (pw, 0, board_width - pw, ph)\n                 r2 = (0, ph, board_width, board_height - ph)\n            \n            if r1[2] > 0 and r1[3] > 0: new_rects.append(r1)\n            if r2[2] > 0 and r2[3] > 0: new_rects.append(r2)\n            \n            boards.append(new_rects)\n\n    return {\n        "num_boards": len(boards),\n        "placements": placements\n    }'}