{'reasoning': "The solver employs a hierarchical strategy to handle varying board complexities efficiently. \n\n1. **Trivial Scale**: It starts with single-cell constraint satisfaction. For any numbered cell, if the number of surrounding mines equals its value, all other neighbors are safe. If the number of surrounding safe cells satisfies the non-mine neighbor count, the rest are mines. This runs in O(N) where N is the number of clues.\n\n2. **Medium Scale**: It uses Set Difference Logic (Constraint Propagation). By comparing two adjacent numbered cells, if the neighbors of one are a subset of the neighbors of another, we can derive a simpler constraint for the difference set. This resolves common patterns like '1-1', '1-2-1', etc. This is O(M^2) where M is the number of active constraints (frontier size), which is highly efficient even for 100x100 boards.\n\n3. **Large/Complex Scale**: When set logic stalls, the solver identifies connected components of unknown cells (islands of coupled constraints). For small components (<= 20 variables), it uses a backtracking 'Tank Solver' to find all valid mine arrangements. If a cell is safe in ALL valid arrangements, it is marked safe. To ensure performance on 'Extreme' boards, components larger than the threshold are skipped or only partially solved, preventing exponential runtime explosions while still solving local clusters.", 'python_code': "import time\n\ndef solve_minesweeper(board):\n    if not board: return []\n    nrows = len(board)\n    ncols = len(board[0])\n    \n    # Parse initial board state\n    known_mines = set()\n    known_safes = set()\n    undetermined = set()\n    clues = {}\n    \n    for r in range(nrows):\n        for c in range(ncols):\n            char = board[r][c]\n            if char == '*':\n                known_mines.add((r, c))\n            elif char == ' ':\n                undetermined.add((r, c))\n            elif '0' <= char <= '8':\n                clues[(r, c)] = int(char)\n                known_safes.add((r, c))\n    \n    original_unknowns = set(undetermined)\n    \n    def get_neighbors(r, c):\n        for dr in (-1, 0, 1):\n            for dc in (-1, 0, 1):\n                if dr == 0 and dc == 0: continue\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < nrows and 0 <= nc < ncols:\n                    yield nr, nc\n\n    # Helper for backtracking solver\n    class TankSolver:\n        def __init__(self, variables, constraints):\n            self.vars = variables\n            self.n = len(variables)\n            self.var_map = {v: i for i, v in enumerate(variables)}\n            self.constraints = []\n            for cells, val in constraints:\n                indices = [self.var_map[c] for c in cells]\n                self.constraints.append((indices, val))\n            self.solutions = []\n\n        def solve(self, idx, current_assignment):\n            # Pruning check\n            for indices, target in self.constraints:\n                current_sum = 0\n                unassigned = 0\n                for var_idx in indices:\n                    if var_idx < idx:\n                        current_sum += current_assignment[var_idx]\n                    else:\n                        unassigned += 1\n                # If partial sum exceeds target or cannot reach target, prune\n                if current_sum > target:\n                    return\n                if current_sum + unassigned < target:\n                    return\n            \n            if idx == self.n:\n                self.solutions.append(list(current_assignment))\n                return\n\n            # Try safe (0)\n            current_assignment[idx] = 0\n            self.solve(idx + 1, current_assignment)\n            \n            # Try mine (1)\n            current_assignment[idx] = 1\n            self.solve(idx + 1, current_assignment)\n\n    start_time = time.time()\n    \n    # Main deductive loop\n    while True:\n        if time.time() - start_time > 280: # 5 minute safety timeout\n            break\n            \n        progress = False\n        active_constraints = set()\n        \n        # 1. Basic Constraint Generation & Trivial Logic\n        # Iterate only clues with unknown neighbors\n        # Optimization: In a persistent object, we would track frontier. Here we scan.\n        current_clues = []\n        for (r, c), val in clues.items():\n            neighbors = []\n            mine_count = 0\n            for nr, nc in get_neighbors(r, c):\n                if (nr, nc) in known_mines:\n                    mine_count += 1\n                elif (nr, nc) in undetermined:\n                    neighbors.append((nr, nc))\n            \n            if not neighbors:\n                continue\n                \n            needed = val - mine_count\n            \n            if needed == 0:\n                # All neighbors are safe\n                for n in neighbors:\n                    undetermined.remove(n)\n                    known_safes.add(n)\n                    progress = True\n            elif needed == len(neighbors):\n                # All neighbors are mines\n                for n in neighbors:\n                    undetermined.remove(n)\n                    known_mines.add(n)\n                    progress = True\n            else:\n                # Store complex constraint\n                active_constraints.add((frozenset(neighbors), needed))\n        \n        if progress:\n            continue\n            \n        if not active_constraints:\n            break\n            \n        # 2. Set Difference Logic (Constraint Propagation)\n        # If constraint A is subset of B, B-A must have remaining mines\n        constraints_list = sorted(list(active_constraints), key=lambda x: len(x[0]))\n        for i in range(len(constraints_list)):\n            s1, k1 = constraints_list[i]\n            for j in range(i + 1, len(constraints_list)):\n                s2, k2 = constraints_list[j]\n                \n                if len(s2) > len(s1) + 4: # Optimization: avoid comparing vastly different sizes\n                    continue\n                    \n                if s1.issubset(s2):\n                    diff = s2 - s1\n                    k_diff = k2 - k1\n                    \n                    if not diff: continue\n                    \n                    if k_diff == 0:\n                        for n in diff:\n                            if n in undetermined:\n                                undetermined.remove(n)\n                                known_safes.add(n)\n                                progress = True\n                    elif k_diff == len(diff):\n                        for n in diff:\n                            if n in undetermined:\n                                undetermined.remove(n)\n                                known_mines.add(n)\n                                progress = True\n            \n            if progress: break\n        \n        if progress:\n            continue\n            \n        # 3. Coupled Component Solver (Backtracking)\n        # Group coupled variables into components\n        adj = {}\n        relevant_vars = set()\n        for cells, k in active_constraints:\n            relevant_vars.update(cells)\n            cell_list = list(cells)\n            for i in range(len(cell_list)):\n                u = cell_list[i]\n                if u not in adj: adj[u] = set()\n                for j in range(i+1, len(cell_list)):\n                    v = cell_list[j]\n                    if v not in adj: adj[v] = set()\n                    adj[u].add(v)\n                    adj[v].add(u)\n        \n        visited = set()\n        for v in relevant_vars:\n            if v in visited: continue\n            \n            # BFS to find component\n            component = []\n            stack = [v]\n            visited.add(v)\n            while stack:\n                curr = stack.pop()\n                component.append(curr)\n                for neighbor in adj.get(curr, []):\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        stack.append(neighbor)\n            \n            # Only solve small components to maintain performance\n            if len(component) <= 18:\n                # Extract relevant constraints\n                comp_set = set(component)\n                comp_constraints = []\n                for cells, k in active_constraints:\n                    if cells.issubset(comp_set):\n                        comp_constraints.append((list(cells), k))\n                \n                solver = TankSolver(component, comp_constraints)\n                solver.solve(0, [0]*len(component))\n                \n                if solver.solutions:\n                    # Aggregate results\n                    # If a cell is 0 in ALL solutions, it is Safe\n                    # If a cell is 1 in ALL solutions, it is Mine\n                    num_sols = len(solver.solutions)\n                    for idx in range(len(component)):\n                        sum_vals = sum(sol[idx] for sol in solver.solutions)\n                        cell = component[idx]\n                        if cell in undetermined:\n                            if sum_vals == 0:\n                                undetermined.remove(cell)\n                                known_safes.add(cell)\n                                progress = True\n                            elif sum_vals == num_sols:\n                                undetermined.remove(cell)\n                                known_mines.add(cell)\n                                progress = True\n            \n            if progress: break\n        \n        if not progress:\n            break\n            \n    # Return only originally unknown safe cells in (x, y) format\n    result = []\n    for r, c in known_safes:\n        if (r, c) in original_unknowns:\n            result.append((c, r))\n            \n    return sorted(result)"}