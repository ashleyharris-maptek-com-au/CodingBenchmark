You are writing a Minesweeper solver.

**Board state:** (12x12, 95 unknown, 6 flagged mines, 43 revealed)

```
  1    1   1
1   1   2   
2220       1
1*  101  2  
  3    1    
1 3         
*1     11 1 
       *1  *
2  0  1 1   
   00     1 
2   00  1*21
1   0 0 1 2*
```

**Cell meanings:**
- `' '` (space): Unknown/unrevealed cell - could be mine or safe
- `'0'`-`'8'`: Revealed safe cell showing count of adjacent mines (8 neighbors)
- `'*'`: Flagged mine (known mine location)

**Your task:**
Write a Python function `solve_minesweeper(board)` that:
- Takes the board as a 2D list of characters (list of lists)
- Returns a list of (x, y) coordinates of cells **guaranteed** to be safe
- x is column (0 = leftmost), y is row (0 = topmost)
- Only return cells that are currently unknown (' ') and provably safe
- Do NOT guess - only return cells you can prove are safe

**Logic for deducing safe cells:**

1. **Satisfied constraint:** If a numbered cell has exactly that many flagged mines adjacent, 
   all other adjacent unknown cells are safe.
   
2. **Subset analysis:** If cell A's unknown neighbors are a subset of cell B's unknown neighbors,
   and their mine counts differ appropriately, deductions can be made.

3. **Constraint propagation:** Apply rules iteratively until no more deductions possible.

**Example:**
```
  012
0 1*
1 11
2   
```
Cell (0,0) shows '1' and has one adjacent mine at (1,0). 
So (0,1) and (0,2) are guaranteed safe.

**Constraints:**
- Solver must complete within 5 minutes
- Use only Python standard library
- Return as many provably safe cells as possible
- Never return a cell that could be a mine

Write complete Python code with the solve_minesweeper function.
