You are solving a Hamiltonian Path problem on a 2D grid with obstacles.

**Grid:** 6 x 5 (30 cells, 6 obstacles, 24 free cells)
**Requirement:** **Must form a cycle** (return to start from last cell)

**Grid visualization** (S=start, #=obstacle, .=free):
```
. . . # . . 
. # . . . # 
. . # . # . 
# . . . . . 
S . . . . . 
```

**Obstacle positions:**
```python
obstacles = {(0, 1), (1, 3), (2, 2), (3, 4), (4, 2), (5, 3)}
```

**Your task:**
Write a Python function `find_hamiltonian_path(width, height, obstacles, require_cycle)` that:
- Takes grid dimensions, set of obstacle coordinates, and cycle requirement
- Returns a list of (x, y) coordinates representing the path
- Path must start at (0, 0)
- Path must visit every non-obstacle cell exactly once
- Movement is only to adjacent cells (up/down/left/right, no diagonals)
- If require_cycle is True, last cell must be adjacent to (0, 0)

**Example output for a 3x3 grid with obstacle at (1,1):**
```python
[(0,0), (0,1), (0,2), (1,2), (2,2), (2,1), (2,0), (1,0)]
```

**Hints:**
- This is NP-complete in general
- Backtracking/DFS is the basic approach
- Pruning heuristics can help: dead-end detection, connectivity checks
- Consider Warnsdorff's rule (prefer cells with fewer unvisited neighbors)

**Constraints:**
- Solver must complete within 5 minutes
- Use only Python standard library
- Return empty list [] if no path exists

Write complete, runnable Python code with the find_hamiltonian_path function.
