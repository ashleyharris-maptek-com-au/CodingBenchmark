You are writing a Minesweeper solver.

**Board state:** (32x32, 805 unknown, 45 flagged mines, 174 revealed)

```
 211      3   2  00      11 0   
* *    1  *     2  1  *      0  
 2      3*         10  *     1  
0 1 *             1 01        00
 1    0 1 3   2       *1      11
    * 0    1 2                  
0 2    0         1              
       22        3 211 0 2 2   *
*    0     *     *    1      0  
   0         11        *    1  *
   0         1   0      *1      
  2 01  3*    1    0 2 2   22 0 
1    0  2                     11
    2              *2  *    * 1 
    *2    **    0      *       1
  012   1  3        * 2 1  1    
           1        3   0     1 
    00                    *2    
  00    *12    *         * 1  11
   1   *            0 00    0   
 1 * 2    2  0   2        1  0  
1   33 3    0                 0 
    3            1        01    
 *   2 1        1 0  1         0
1    *  0          0  0  *      
     *3 133        00  0     00 
     4    *       0    01       
    *   2    4   0 0            
  2  21        *     *          
1 2         1    1 *3 1        0
    1  * 0       *      1   2   
  0    *   *  10 1   0 0       *
```

**Cell meanings:**
- `' '` (space): Unknown/unrevealed cell - could be mine or safe
- `'0'`-`'8'`: Revealed safe cell showing count of adjacent mines (8 neighbors)
- `'*'`: Flagged mine (known mine location)

**Your task:**
Write a Python function `solve_minesweeper(board)` that:
- Takes the board as a 2D list of characters (list of lists)
- Returns a list of (x, y) coordinates of cells **guaranteed** to be safe
- x is column (0 = leftmost), y is row (0 = topmost)
- Only return cells that are currently unknown (' ') and provably safe
- Do NOT guess - only return cells you can prove are safe

**Logic for deducing safe cells:**

1. **Satisfied constraint:** If a numbered cell has exactly that many flagged mines adjacent, 
   all other adjacent unknown cells are safe.
   
2. **Subset analysis:** If cell A's unknown neighbors are a subset of cell B's unknown neighbors,
   and their mine counts differ appropriately, deductions can be made.

3. **Constraint propagation:** Apply rules iteratively until no more deductions possible.

**Example:**
```
  012
0 1*
1 11
2   
```
Cell (0,0) shows '1' and has one adjacent mine at (1,0). 
So (0,1) and (0,2) are guaranteed safe.

**Constraints:**
- Solver must complete within 5 minutes
- Use only Python standard library
- Return as many provably safe cells as possible
- Never return a cell that could be a mine

Write complete Python code with the solve_minesweeper function.
