You are solving a Hamiltonian Path problem on a 2D grid with obstacles.

**Grid:** 6 x 6 (36 cells, 8 obstacles, 28 free cells)
**Requirement:** Path only (no need to return to start)

**Grid visualization** (S=start, #=obstacle, .=free):
```
. . . . # . 
. # . . . . 
. . . . # # 
. . . . . . 
. . . . # . 
S # # . . # 
```

**Obstacle positions:**
```python
obstacles = {(1, 0), (1, 4), (2, 0), (4, 1), (4, 3), (4, 5), (5, 0), (5, 3)}
```

**Your task:**
Write a Python function `find_hamiltonian_path(width, height, obstacles, require_cycle)` that:
- Takes grid dimensions, set of obstacle coordinates, and cycle requirement
- Returns a list of (x, y) coordinates representing the path
- Path must start at (0, 0)
- Path must visit every non-obstacle cell exactly once
- Movement is only to adjacent cells (up/down/left/right, no diagonals)
- If require_cycle is True, last cell must be adjacent to (0, 0)

**Example output for a 3x3 grid with obstacle at (1,1):**
```python
[(0,0), (0,1), (0,2), (1,2), (2,2), (2,1), (2,0), (1,0)]
```

**Hints:**
- This is NP-complete in general
- Backtracking/DFS is the basic approach
- Pruning heuristics can help: dead-end detection, connectivity checks
- Consider Warnsdorff's rule (prefer cells with fewer unvisited neighbors)

**Constraints:**
- Solver must complete within 5 minutes
- Use only Python standard library
- Return empty list [] if no path exists

Write complete, runnable Python code with the find_hamiltonian_path function.
