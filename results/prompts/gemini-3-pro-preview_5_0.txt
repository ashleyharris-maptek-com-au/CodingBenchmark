You are solving a Hamiltonian Path problem on 2D grids with obstacles.

You must write a Python solver that can handle ANY grid size from trivial to ludicrous scale:

Your `find_hamiltonian_path(width, height, obstacles, require_cycle)` function will be tested with grids ranging from 4x4 to 50x50. 
The same function must work efficiently across ALL scales.

**Input:**
- `width`, `height`: Grid dimensions
- `obstacles`: Set of (x, y) tuples for blocked cells
- `require_cycle`: Boolean - if True, must form cycle back to start

**Output:**
- List of (x, y) coordinates representing the path
- Path must start at (0, 0)
- Path must visit every non-obstacle cell exactly once
- Movement is only to adjacent cells (up/down/left/right)
- If require_cycle is True, last cell must be adjacent to (0, 0)

**Critical Requirements:**
1. **Scalability**: Your algorithm must adapt based on grid size and obstacle density
2. **Performance**: Must complete within 5 minutes even for 2500 cell grids
3. **Correctness**: Must find valid paths or correctly report impossibility

**Constraints:**
- Use only Python standard library
- Return empty list [] if no path exists
- Must handle both path-only and cycle requirements

Write complete, runnable Python code with the find_hamiltonian_path function.
Include adaptive logic that chooses different strategies based on grid size.
