You are solving a Job-Shop Scheduling problem.

**Problem:**
Schedule tasks on machines to minimize makespan (total completion time).

**Machines:** 4 (numbered 0 to 3)

**Jobs:** (5 jobs, 20 tasks total)
```
    Job 0: [(M2, d=6), (M1, d=5), (M0, d=2), (M3, d=4)]
    Job 1: [(M0, d=4), (M2, d=4), (M1, d=6), (M3, d=3)]
    Job 2: [(M0, d=5), (M3, d=5), (M2, d=2), (M1, d=5)]
    Job 3: [(M2, d=4), (M0, d=5), (M3, d=6), (M1, d=5)]
    Job 4: [(M2, d=5), (M0, d=6), (M1, d=4), (M3, d=2)]
```

**Full jobs data:**
```python
jobs = [[{'machine': 2, 'duration': 6}, {'machine': 1, 'duration': 5}, {'machine': 0, 'duration': 2}, {'machine': 3, 'duration': 4}], [{'machine': 0, 'duration': 4}, {'machine': 2, 'duration': 4}, {'machine': 1, 'duration': 6}, {'machine': 3, 'duration': 3}], [{'machine': 0, 'duration': 5}, {'machine': 3, 'duration': 5}, {'machine': 2, 'duration': 2}, {'machine': 1, 'duration': 5}], [{'machine': 2, 'duration': 4}, {'machine': 0, 'duration': 5}, {'machine': 3, 'duration': 6}, {'machine': 1, 'duration': 5}], [{'machine': 2, 'duration': 5}, {'machine': 0, 'duration': 6}, {'machine': 1, 'duration': 4}, {'machine': 3, 'duration': 2}]]
num_machines = 4
```

**Constraints:**
1. Each task in a job must run on its specified machine
2. Tasks within a job must execute in order (task i before task i+1)
3. A machine can only run one task at a time
4. Tasks cannot be interrupted once started
5. Total work duration: 88 time units

**Your task:**
Write a Python function `schedule_jobs(jobs, num_machines)` that:
- Takes list of jobs and number of machines
- Returns a dict with:
  - `"makespan"`: Total completion time (when last task finishes)
  - `"schedule"`: List of lists - for each job, for each task: (start_time, machine)

**Example output:**
```python
{
    "makespan": 12,
    "schedule": [
        [(0, 0), (3, 1)],     # Job 0: task 0 starts at t=0 on M0, task 1 at t=3 on M1
        [(0, 1), (5, 0)],     # Job 1: task 0 starts at t=0 on M1, task 1 at t=5 on M0
    ]
}
```

**Algorithms:**
1. **Greedy/List scheduling:** Sort tasks by priority, schedule earliest possible
2. **Shifting Bottleneck:** Solve one-machine problems iteratively
3. **Genetic algorithms:** Evolve permutation of operations
4. **Branch and bound:** Exact but exponential

**Priority rules for greedy:**
- SPT (Shortest Processing Time)
- LPT (Longest Processing Time)
- FIFO (First In First Out)
- Most Work Remaining

**Constraints:**
- Solver must complete within 5 minutes
- Use only Python standard library

Write complete Python code with the schedule_jobs function.
