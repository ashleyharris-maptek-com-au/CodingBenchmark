You are solving the Chinese Postman Problem (Route Inspection Problem).

Given an undirected weighted graph, find the shortest route that:
1. Starts at node 0
2. Traverses EVERY edge at least once
3. Returns to node 0
4. Minimizes total distance traveled

**Graph:** 10 nodes (labeled 0 to 9), 16 edges

**Edges (node1, node2, weight):**
```python
edges = [
    (6, 9, 17),  # Edge between node 6 and 9, weight 17
    (6, 7, 88),  # Edge between node 6 and 7, weight 88
    (8, 9, 77),  # Edge between node 8 and 9, weight 77
    (0, 9, 12),  # Edge between node 0 and 9, weight 12
    (1, 8, 16),  # Edge between node 1 and 8, weight 16
    (5, 7, 43),  # Edge between node 5 and 7, weight 43
    (2, 9, 47),  # Edge between node 2 and 9, weight 47
    (4, 8, 42),  # Edge between node 4 and 8, weight 42
    (0, 3, 37),  # Edge between node 0 and 3, weight 37
    (7, 9, 37),  # Edge between node 7 and 9, weight 37
    (0, 2, 55),  # Edge between node 0 and 2, weight 55
    (4, 6, 50),  # Edge between node 4 and 6, weight 50
    (0, 8, 19),  # Edge between node 0 and 8, weight 19
    (3, 7, 87),  # Edge between node 3 and 7, weight 87
    (0, 6, 88),  # Edge between node 0 and 6, weight 88
    (4, 9, 55),  # Edge between node 4 and 9, weight 55
]
```

**Your task:**
Write a Python function `solve_cpp(num_nodes, edges)` that takes:
- `num_nodes`: number of nodes in the graph
- `edges`: list of (node1, node2, weight) tuples

Returns a list of node indices representing the route (starting and ending at node 0).

**Key insight:** 
- If all vertices have even degree, an Eulerian circuit exists (traverse each edge exactly once)
- If some vertices have odd degree, some edges must be traversed twice
- The challenge is minimizing which edges get duplicated

**Constraints:**
- Your solver must complete within 5 minutes
- You may use only Python standard library
- The returned route must visit every edge at least once

Write complete, runnable Python code with the solve_cpp function.
